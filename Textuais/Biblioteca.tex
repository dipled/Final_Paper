\chapter{Implementação em Rocq}\label{cap:implementacao}

Neste capítulo será descrita a implementação da biblioteca da lógica de inconsistência formal \lfium{} no assistente de provas Rocq (anteriormente conhecido como Coq), bem como o desenvolvimento de alguns metateoremas apresentados na Seção~\ref{sec:metateoremas} dentro da biblioteca. A implementação será análoga àquela feita por~\citeshort{silveira2020implementacao}, que implementou uma biblioteca de lógica modal. Antes de tratar especificamente da implementação, o Rocq será brevemente apresentado e caracterizado.

\section{Assistente de provas Rocq}\label{sec:rocq}
    Os assistentes de provas são ferramentas de \textit{software} que auxiliam o usuário no desenvolvimento de teoremas, permitindo que provas sejam verificadas na medida em que são escritas~\cite{geuvers2009proof}, conferindo a estes programas uma importância significativa na verificação e especificação formal de \textit{software}. Atualmente, existem diversos assistentes de provas como: Agda, Isabelle, Rocq, Lean, HOL, Idris e Twelf. Cada um destes tem suas particularidades e diferenças em relação ao formalismo matemático utilizado como base.

    O Rocq é um assistente de provas baseado no Cálculo de Construções Indutivas (CCI) que possui aplicações em diferentes áreas da matemática e da computação como (mas não limitado a) lógica, linguagens formais, linguística computacional e desenvolvimento de programas seguros~\cite{coqart}. Sob a ótica da Correspondência de Curry{-}Howard, o Rocq é tanto uma linguagem de programação funcional quanto uma linguagem de prova, podendo ser dividido em quatro partes~\cite{silva2019certificaccao}:
    
    \begin{itemize}
        \item A linguagem de programação e especificação \textit{Gallina}, que goza da propriedade da normalização forte\footnote{Um termo-$\lambda$ é fortemente normalizável caso toda sequência de reescrita acabe numa forma normal (num termo irredutível). Um sistema no qual todos os termos-$\lambda$ são fortemente normalizáveis possui a propriedade da normalização forte~\cite{nipkow2006rewriting}.}, a qual garante que todo programa termina.
        \item A linguagem de comandos \textit{Vernacular}, que permite interagir com o assistente.
        \item O conjunto de táticas (\textit{tactics}) utilizadas para manipular elementos durante o desenvolvimento de uma prova.
        \item A linguagem $\pazocal{L}$tac, utilizada para implementar novas táticas e automatizar provas.
    \end{itemize}

    No restante desse trabalho, conceitos básicos sobre o funcionamento do assistente de provas Rocq e sobre seu uso no desenvolvimento de provas e verificação de provas não serão apresentados em grandes detalhes. Ao leitor interessado em tais assuntos, é recomendada uma consulta aos trabalhos de~\citeshort{Pierce2017Logical} e~\citeshort{silveira2020implementacao}.

\section{Biblioteca em Rocq}\label{sec:biblioteca}
    Nesta seção será apresentada a biblioteca para a lógica \lfium{}, com os principais artefatos semânticos e sintáticos apresentados ao longo do trabalho, bem como provas para os metateoremas que foram provados manualmente. A biblioteca foi desenvolvida utilizando a versão 9.0.0 do Rocq e está disponível em \url{https://github.com/dipled/LFI1_Library}. Cada subseção representa um arquivo da biblioteca e as partes mais importantes de cada um destes será comentada ao longo do texto.

    \subsection{Utils.v}\label{sec:utils}

      Este arquivo contem algumas notações, definições e propriedades úteis que foram estabelecidas para facilitar a implementação.

      \begin{lstlisting}[name=Utils, frame=single, language=coq]
Require Import Arith Constructive_sets.
$\qquad\vdots$
Notation " a $\in$ A " := (In A a) (at level 10).
Notation " a $\not \in$ A " := (~In A a) (at level 10).
Notation " B $\cup$ C " := (Union B C) (at level 48, left associativity).
Notation " [ a ] " := (Singleton a) (at level 0, right associativity).
Notation " A $\subseteq$ B " := (Included A B) (at level 71). 
Notation " $\varnothing$ "     := (Empty_set).
      \end{lstlisting}

      As bibliotecas \texttt{Arith} e \texttt{Constructive\_sets} fornecem alguns teoremas e definições fundamentais para trabalhar com conjuntos em Rocq, na forma de estruturas chamadas de \texttt{Ensembles}, que são mapeamentos de um tipo qualquer \texttt{U} para \texttt{Prop}. A fim de facilitar a leitura do código, foram estabelecidas notações para conceitos de pertinência, união e contingência de conjuntos e conjuntos vazio e \textit{singleton}.

      \begin{lstlisting}[name=Utils, frame=single, language=coq]
Theorem iff_neg : forall A B : Prop, (A <-> B) -> (~A <-> ~B).
$\qquad\vdots$
Theorem contra : forall A B : Prop, (A -> B) -> (~B -> ~A).
$\qquad\vdots$
Ltac destruct_conjunction H :=
match type of H with
| _ /\ _ => 
  let L := fresh "L" in
  let R := fresh "R" in
  destruct H as [L R]; destruct_conjunction L; destruct_conjunction R
| _ => idtac
end.
      \end{lstlisting}

      O $\pazocal{L}$tac  \texttt{destruct\_conjunction} é uma tática que recebe como argumento uma hipótese \texttt{H} e caso esta hipótese seja uma conjunção, ela é destruída em duas novas hipóteses \texttt{L} e \texttt{R} e a tática é repetida recursivamente para cada uma destas hipóteses.

      \subsection{Language.v}\label{sec:language}

      Este arquivo contem a definição da linguagem da \lfium{}, como apresentada na Seção~\ref{sec:linguagem}.

      \begin{lstlisting}[name=Language, frame=single, language=coq]
Require Import LFI1.Utils.
From Stdlib Require Import Arith Constructive_sets.

Definition Atom := nat.

Inductive Formula : Set :=
  | Lit    : Atom -> Formula
  | Neg    : Formula -> Formula
  | And    : Formula -> Formula -> Formula
  | Or     : Formula -> Formula -> Formula
  | Imp    : Formula -> Formula -> Formula
  | Consistency   : Formula -> Formula.

Notation " x $\to$ y " := 
(Imp x y) (at level 8, right associativity).

Notation " x $\land$ y " := 
(And x y) (at level 6, left associativity).

Notation " x $\lor$ y " := 
(Or x y) (at level 7, left associativity).

Notation " $\neg$ x " := 
(Neg x) (at level 5, right associativity, format "\neg x").

Notation " $\circ$ x " := 
(Consistency x) (at level 5, right associativity, format "$\circ$ x").

Notation " $\#$ x " :=
(Lit x) (at level 2, no associativity, x constr at level 1, format "$\#$ x").
      \end{lstlisting}
      
      Note que \texttt{Lit} é construído a partir de um \texttt{Atom}, que por sua vez é só um \textit{alias} para o tipo \texttt{nat} (um número natural), portanto o tipo indutivo \texttt{Formula} é enumerável.

    \subsection{Syntax.v}\label{sec:syntax}

      Este arquivo contem a definição da sintaxe da \lfium{}, através do cáclulo de Hilbert definido na Seção~\ref{sec:axiomatizacao}.

      \begin{lstlisting}[name=Syntax, frame=single, language=coq]
Require Import LFI1.Utils LFI1.Language.
From Stdlib Require Import Arith Constructive_sets.

(* Hilbert calculus: *)

Inductive Ax : Set :=
  | Ax1      : Formula -> Formula -> Ax
  | Ax2      : Formula -> Formula -> Formula -> Ax
$\qquad\vdots$
  | bc1      : Formula -> Formula -> Ax
  | cf       : Formula -> Ax
  | ce       : Formula -> Ax
  | ci       : Formula -> Ax
$\qquad\vdots$
Definition instantiate (a : Ax) : Formula :=
  match a with 
  | Ax1 $\alpha$ $\beta$      => $\alpha$ $\to$ ($\beta$ $\to$ $\alpha$)
  | Ax2 $\alpha$ $\beta$ $\gamma$    => ($\alpha$ $\to$ ($\beta$ $\to$ $\gamma$)) $\to$ (($\alpha$ $\to$ $\beta$) $\to$ ($\alpha$ $\to$ $\gamma$))
$\qquad\vdots$
  | bc1 $\alpha$ $\beta$      => $\circ$$\alpha$ $\to$ ($\alpha$ $\to$ ($\neg$$\alpha$ $\to$ $\beta$))
  | cf $\alpha$         => $\neg$$\neg$$\alpha$ $\to$ $\alpha$
  | ce $\alpha$         => $\alpha$ $\to$ $\neg$$\neg$$\alpha$
  | ci $\alpha$         => $\neg$$\circ$$\alpha$ $\to$ ($\alpha$ $\land$ $\neg$ $\alpha$)
$\qquad\vdots$
  end.
  
Inductive deduction : Ensemble Formula -> Formula -> Prop :=
  | Premisse : forall ($\Gamma$ : Ensemble Formula) ($\phi$ : Formula), $\phi$ $\in$ $\Gamma$ -> deduction $\Gamma$ $\phi$
  | AxiomInstance : forall ($\Gamma$ : Ensemble Formula) (a : Ax), deduction $\Gamma$ (instantiate a)
  | MP : forall ($\Gamma$ : Ensemble Formula) ($\phi$ $\psi$ : Formula), (deduction $\Gamma$ ($\phi$ $\to$ $\psi$)) -> 
    (deduction $\Gamma$ $\phi$) -> deduction $\Gamma$ $\psi$.

Notation " $\Gamma$ $\vdash$ $\phi$ " := (deduction $\Gamma$ $\phi$) (at level 50, no associativity).
      \end{lstlisting}

      Primeiro, o tipo \texttt{Ax} foi definido como um tipo indutivo (também chamado de tipo algébrico), com construtores que recebem como argumentos fórmulas correspondentes ao número de fórmulas dos axiomas definidos na Definição~\ref{def:hilbert_lfi1}. 
      
      Depois, a função \texttt{instantiate} é definida. Ela recebe como argumento um axioma (que por sua vez foi construído a partir de fórmulas) e retorna uma formula correspondente àquela representada pelo axioma, por exemplo, o axioma~\ref{ax:axcf} representa a eliminação da dupla negação, portanto, a função \texttt{instantiate} receberia um dado \texttt{cf $\alpha$} do tipo \texttt{Ax}, onde $\alpha$ é uma fórmula qualquer da linguagem, e retornaria um dado $\neg\neg\alpha \to \alpha$ do tipo \texttt{Formula}.

      Finalmente, o tipo \texttt{deduction} é definido indutivamente a partir de um conjunto de fórmulas (conjunto de premissas) e uma fórmula (conclusão) e retornando um dado do tipo \texttt{Prop} referente a possibilidade de construir uma derivação da conclusão a partir do conjunto de premissas, aplicando uma sequência de construtores, que representam os três casos de derivação descritos na Definição~\ref{def:derivacao}. O construtor \texttt{Premisse} diz que se uma fórmula qualquer pertence ao conjunto de premissas, então ela é derivável a partir deste conjunto. O construtor \texttt{AxiomInstance} diz que um axioma é sempre derivável a partir de qualquer conjunto de premissas. O construtor \texttt{MP} diz que, dadas duas fórmulas $\phi$ e $\psi$ quaisquer, se for possível derivar $\phi \to \psi$ e $\phi$ a partir de um conjunto de fórmulas, então podemos derivar $\psi$ a partir deste mesmo conjunto. Por último, uma notação com o operador infixo $\vdash$ é estabelecida para facilitar a leitura de derivações.
    
    \subsection{Semantics.v}

      Este arquivo contem a definição dos dois sistemas semânticos apresentados na Seção~\ref{sec:semantica}.

      O primeiro sistema definido foi a semântica matricial, conforme as Definições~\ref{def:mat} e~\ref{def:conmat}.
      \begin{lstlisting}[name=Semantics, frame=single, language=coq]
Require Import LFI1.Utils LFI1.Language.
From Stdlib Require Import Arith Constructive_sets.

(* Matrix Semantics: *)

Inductive MatrixDomain : Set :=
  | One
  | Half
  | Zero.

Definition designatedValue (a : MatrixDomain) : Prop :=
  match a with
  | Zero => False
  | _ => True
  end.

Definition andM (a b : MatrixDomain) : MatrixDomain :=
  match a, b with
  | Zero, _  => Zero
  | _, Zero  => Zero
  | One, One => One
  | _, _     => Half
  end.

Definition orM (a b : MatrixDomain) : MatrixDomain :=
  match a, b with
  | One, _     => One
  | _, One     => One
  | Zero, Zero => Zero
  | _, _       => Half
  end.

Definition impM (a b : MatrixDomain) : MatrixDomain :=
  match a, b with
  | Zero, _ => One
  | _, One  => One
  | _, Half => Half

  | _, Zero => Zero
  end.

Definition negM (a : MatrixDomain) : MatrixDomain :=
  match a with
  | One  => Zero
  | Half => Half
  | Zero => One
  end.

Definition consM (a : MatrixDomain) : MatrixDomain :=
  match a with
  | Half => Zero
  | _    => One
  end.

Notation " x $\to_{m}$ y " := 
(impM x y) (at level 21, right associativity).

Notation " x $\land_{m}$ y " := 
(andM x y) (at level 20, left associativity).

Notation " x $\lor_{m}$ y " := 
(orM x y) (at level 22, left associativity).

Notation " $\neg_{m}$ x " := 
(negM x) (at level 9, right associativity, format "$\neg_{m}$ x").

Notation " $\circ_{m}$ x " := 
(consM x) (at level 9, right associativity, format "$\circ_{m}$ x").
        
      \end{lstlisting}
      Note que \texttt{designatedValue} é um predicado sobre o domínio da matriz lógica, e retorna um \texttt{Prop} referente a pertinência de um dado valor ao conjunto $\{1,\meio{}\}$.

      Após definir a matriz lógica, é preciso estabelecer a noção de valorações sobre essa matriz, conforme apresentada na Definição~\ref{def:matlog}, que define valoração como um homomorfismo entre linguagem e a álgebra da matriz, preservando a estrutura dos seus operadores.
    
      \begin{lstlisting}[name=Semantics, frame=single, language=coq]
(* Defining the conditions for a function to be a valuation over the matrix,
i.e., it must be a homomorphism from Formula to MatrixDomain.
*)

Definition preserveAnd (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$ $\psi$: Formula, (v ($\phi$ $\land$ $\psi$)) = (v $\phi$) $\land_{m}$ (v $\psi$).

Definition preserveOr (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$ $\psi$: Formula, (v ($\phi$ $\lor$ $\psi$)) = (v $\phi$) $\lor_{m}$ (v $\psi$).

Definition preserveTo (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$ $\psi$: Formula, (v ($\phi$ $\to$ $\psi$)) = (v $\phi$) $\to_{m}$ (v $\psi$).

Definition preserveNeg (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$: Formula, (v ($\neg$$\phi$)) = $\neg_{m}$(v $\phi$).

Definition preserveCirc (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$: Formula, (v ($\circ$$\phi$)) = $\circ_{m}$(v $\phi$).

Definition valuation (v : Formula -> MatrixDomain) : Prop :=
preserveOr v /\ preserveTo v /\ preserveAnd v /\ preserveNeg v /\ preserveCirc v.

(* Defining the semantic consequence relation w.r.t matrices *)
Definition matrixEntails ($\Gamma$ : Ensemble Formula) ($\phi$ : Formula) := 
forall v : (Formula -> MatrixDomain),
valuation v -> 
(forall ($\psi$: Formula), 
  $\psi$ $\in$ $\Gamma$ -> designatedValue (v $\psi$)) -> 
    designatedValue (v $\phi$).

Notation " $\Gamma$ $\vDash$m $\phi$ " := (matrixEntails $\Gamma$ $\phi$) (at level 50, no associativity).
      \end{lstlisting}

      A definição \texttt{valuation} representa um predicado sobre qualquer mapeamento de \texttt{Formula} para \texttt{MatrixDomain}, que retorna \texttt{True} caso este mapeamento seja um homomorfismo sobre a linguagem e o domínio da matriz e retorna \texttt{False} caso contrário. A relação de consequência semântica é definida em \texttt{matrixEntails} (conforme a Definição~\ref{def:conmat}), que diz que, dado um conjunto de fórmulas (conjunto de premissas) e uma fórmula (conclusão), esta fórmula será uma consequência semântica do conjunto de premissas caso toda valoração que satisfaz todas as fórmulas deste conjunto também satisfizer a conclusão.

      Depois disso, a semântica de bivalorações foi implementada, com base nas Definições~\ref{def:valoracoes} e~\ref{def:conval}.

      \begin{lstlisting}[name=Semantics, frame=single, language=coq]
(* Bivaluation semantics *)

Inductive BivaluationDomain : Set :=
  | Bot
  | Top.

Notation " $\bot$ " := Bot.
Notation " $\top$ " := Top.

(* Defining the conditions a given map from Formula to BivaluationDomain must
    follow in order to be a bivaluation (it doesn't have to be a homomorphism)
*)
Definition vAnd (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ $\psi$ : Formula, (v ($\phi$ $\land$ $\psi$)) = $\top$ <-> (v $\phi$ = $\top$) /\ (v $\psi$ = $\top$).

Definition vOr (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ $\psi$ : Formula, (v ($\phi$ $\lor$ $\psi$)) = $\top$ <-> (v $\phi$ = $\top$) \/ (v $\psi$ = $\top$).

Definition vImp (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ $\psi$ : Formula, (v ($\phi$ $\to$ $\psi$)) = $\top$ <-> (v $\phi$ = $\bot$) \/ (v $\psi$ = $\top$).

Definition vNeg (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ : Formula, (v $\neg$$\phi$) = $\bot$ -> v $\phi$ = $\top$.

Definition vCon (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ : Formula, (v $\circ$$\phi$) = $\top$ -> (v $\phi$ = $\bot$) \/ (v $\neg$$\phi$ = $\bot$).

Definition vCi (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ : Formula, (v $\neg$$\circ$$\phi$) = $\top$ -> (v $\phi$ = $\top$) /\ (v $\neg$$\phi$ = $\top$).

Definition vDne (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ : Formula, (v $\neg$$\neg$$\phi$) = $\top$ <-> v $\phi$ = $\top$.

Definition vDmAND (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ $\psi$ : Formula, (v $\neg$($\phi$ $\land$ $\psi$)) = $\top$ <-> (v $\neg$$\phi$ = $\top$) \/ (v $\neg$$\psi$ = $\top$).

Definition vDmOR (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ $\psi$ : Formula, (v $\neg$($\phi$ $\lor$ $\psi$)) = $\top$ <-> (v $\neg$$\phi$ = $\top$) /\ (v $\neg$$\psi$ = $\top$).

Definition vCip (v : Formula -> BivaluationDomain) : Prop :=
  forall $\phi$ $\psi$ : Formula, (v $\neg$($\phi$ $\to$ $\psi$)) = $\top$ <-> (v $\phi$ = $\top$) /\ (v $\neg$$\psi$ = $\top$).
  
Definition bivaluation (v : Formula -> BivaluationDomain) : Prop :=
  vAnd v /\ vOr v /\ vImp v /\ vNeg v /\ vCon v /\ vCi v /\
  vDne v /\ vDmAND v /\ vDmOR v /\ vCip v.
              \end{lstlisting}

              A bivaloração é definida sobre um tipo indutivo com construtores $\top$ e $\bot$, representando respectivamente os valores para verdade e falsidade do domínio. As cláusulas \texttt{vAnd} até \texttt{vCip} definem as condições que um mapeamento entre \texttt{Formula} e \texttt{BivaluationDomain} precisam respeitar para serem consideradas bivalorações, caracterizadas pelo predicado \texttt{bivaluation}. Estes mapeamentos apresentam um comportamento não-determinístico em algumas cláusulas, como na cláusula \texttt{vNeg}.

              Após definir estas cláusulas, algumas propriedades úteis sobre a semântica de bivalorações (como o terceiro excluído em \texttt{bivaluation\_lem}) são provadas.

              \begin{lstlisting}[name=Semantics, frame=single, language=coq]
Lemma bivaluation_lem : forall (v : Formula -> BivaluationDomain) ($\phi$ : Formula),
(v $\phi$ = $\top$) \/ (v $\phi$ = $\bot$).
Proof.
$\quad\vdots$
Qed.

Lemma bivaluation_dec1 : forall (v : Formula -> BivaluationDomain) ($\phi$ : Formula),
v $\phi$ = $\top$ <-> ~ v $\phi$ = $\bot$.
Proof.
$\quad\vdots$
Qed.

Lemma bivaluation_dec2 : forall (v : Formula -> BivaluationDomain) ($\phi$ : Formula),
v $\phi$ = $\bot$ <-> ~ v $\phi$ = $\top$.
Proof.
$\quad\vdots$
Qed.

Definition vAndf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ $\psi$ : Formula, (v ($\phi$ $\land$ $\psi$)) = $\bot$ <-> (v $\phi$ = $\bot$) \/ (v $\psi$ = $\bot$).

Definition vOrf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ $\psi$ : Formula, (v ($\phi$ $\lor$ $\psi$)) = $\bot$ <-> (v $\phi$ = $\bot$) /\ (v $\psi$ = $\bot$).

Definition vImpf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ $\psi$ : Formula, (v ($\phi$ $\to$ $\psi$)) = $\bot$ <-> (v $\phi$ = $\top$) /\ (v $\psi$ = $\bot$).

Definition vNegf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ : Formula, (v $\phi$) = $\bot$ -> (v $\neg$$\phi$) = $\top$.

Definition vConf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ : Formula, (v $\phi$ = $\top$) /\ (v $\neg$$\phi$ = $\top$) -> (v $\circ$$\phi$) = $\bot$.

Definition vCif (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ : Formula, (v $\phi$ = $\bot$) \/ (v $\neg$$\phi$ = $\bot$) -> (v $\neg$$\circ$$\phi$) = $\bot$.

Definition vDnef (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ : Formula, (v $\neg$$\neg$$\phi$) = $\bot$ <-> v $\phi$ = $\bot$.

Definition vDmANDf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ $\psi$ : Formula, (v $\neg$($\phi$ $\land$ $\psi$)) = $\bot$ <-> (v $\neg$$\phi$ = $\bot$) /\ (v $\neg$$\psi$ = $\bot$).

Definition vDmORf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ $\psi$ : Formula, (v $\neg$($\phi$ $\lor$ $\psi$)) = $\bot$ <-> (v $\neg$$\phi$ = $\bot$) \/ (v $\neg$$\psi$ = $\bot$).

Definition vCipf (v : Formula -> BivaluationDomain) : Prop :=
forall $\phi$ $\psi$ : Formula, (v $\neg$($\phi$ $\to$ $\psi$)) = $\bot$ <-> (v $\phi$ = $\bot$) \/ (v $\neg$$\psi$ = $\bot$).

Lemma bivaluation_additional : 
forall (v : Formula -> BivaluationDomain),
bivaluation v ->
vAndf v /\ vOrf v /\ vImpf v /\ vNegf v /\ vConf v /\ vCif v /\
vDnef v /\ vDmANDf v /\ vDmORf v /\ vCipf v.
Proof.
$\quad\vdots$
Qed.
            \end{lstlisting}
            As provas de \texttt{bivaluation\_lem}, \texttt{bivaluation\_dec1} e \texttt{bivaluation\_dec2} seguem por análise de caso em \texttt{v($\phi$)}.

            O lema \texttt{bivaluation\_additional} demonstra cláusulas úteis na prova da completude em relação a semântica de bivalorações, que são derivadas das cláusulas estabelecidas originalmente. Nas provas manuais estas cláusulas foram consideradas triviais e, portanto, não foram demonstradas. Este lema segue por análise de caso em \texttt{v($\phi$)} e \texttt{v($\psi$)}.

          \subsection{Deduction\_metatheorem.v}

            Este arquivo contém a prova do metateorema da dedução dentro da biblioteca, análoga à prova manual do Teorema~\ref{teo:deducao}. Antes de provar este teorema, alguns lemas e proposições auxiliares foram demonstrados.
          
          \begin{lstlisting}[name=Deduction, frame=single, language=coq]
Require Import LFI1.Utils LFI1.Language LFI1.Syntax.
From Stdlib Require Import Arith Constructive_sets.

(* LFI1 is tarskian, i.e., it enjoys reflexivity, monotonicity
   and cut
*)
Proposition lfi1_reflexivity : 
forall ($\Gamma$ : Ensemble Formula) ($\phi$ : Formula),
  $\phi$ $\in$ $\Gamma$ -> $\Gamma$ $\vdash$ $\phi$.
Proof.
$\quad\vdots$
Qed.

Proposition lfi1_monotonicity :
forall ($\Gamma$ $\Delta$ : Ensemble Formula) ($\phi$ : Formula),
  $\Delta$ $\vdash$ $\phi$ /\ $\Delta$ $\subseteq$ $\Gamma$ -> $\Gamma$ $\vdash$ $\phi$.
Proof.
$\quad\vdots$
Qed.

Proposition lfi1_cut :
forall ($\Gamma$ $\Delta$ : Ensemble Formula) ($\phi$ : Formula),
  $\Delta$ $\vdash$ $\phi$ /\ (forall ($\delta$ : Formula), $\delta$ $\in$ $\Delta$ -> $\Gamma$ $\vdash$ $\delta$) -> $\Gamma$ $\vdash$ $\phi$.
Proof.
$\quad\vdots$
Qed.

Lemma id : forall ($\Gamma$ : Ensemble Formula) ($\phi$ : Formula), $\Gamma$ $\vdash$ $\phi$ $\to$ $\phi$.
Proof.
$\quad\vdots$
Qed.

          \end{lstlisting}

          Em particular, a prova da monotonicidade em \texttt{lfi1\_monotonicity} é de suma importância no desenvolvimento das demonstrações das metapropriedades mais elaboradas. A prova desta propriedade se dá por indução estrutural na derivação $\Delta \vdash \phi$.

          Depois disso, o teorema da dedução é finalmente provado.

          \begin{lstlisting}[name=Deduction, frame=single, language=coq]
Theorem deduction_metatheorem : forall ($\Gamma$ : Ensemble Formula) ($\alpha$ $\beta$ : Formula), 
(($\Gamma$ $\cup$ [$\alpha$]) $\vdash$ $\beta$) <-> ($\Gamma$ $\vdash$ $\alpha$ $\to$ $\beta$).
Proof. 
$\quad\vdots$
Qed.

Corollary proof_by_cases : forall ($\Gamma$ : Ensemble Formula) ($\alpha$ $\beta$ $\phi$ : Formula), 
($\Gamma$ $\cup$ [$\alpha$] $\vdash$ $\phi$) /\ ($\Gamma$ $\cup$ [$\beta$] $\vdash$ $\phi$) -> ($\Gamma$ $\cup$ [$\alpha$ $\lor$ $\beta$] $\vdash$ $\phi$).
Proof.
$\quad\vdots$
Qed.
  
Corollary proof_by_cases_neg : forall ($\Gamma$ : Ensemble Formula) ($\alpha$ $\phi$ : Formula), 
($\Gamma$ $\cup$ [$\alpha$] $\vdash$ $\phi$) /\ ($\Gamma$ $\cup$ [$\neg$$\alpha$] $\vdash$ $\phi$) -> ($\Gamma$ $\vdash$ $\phi$).
Proof.
$\quad\vdots$
Qed.
          \end{lstlisting}

          A prova segue por indução estrutural na derivação $\Gamma \cup [\alpha] \vdash \beta$ na ida e na derivação $\Gamma \vdash \alpha \to \beta$ na volta. O teorema nos cede dois corolários (\texttt{proof\_by\_cases} e \texttt{proof\_by\_cases\_neg}) que facilitam a prova da completude em relação à semântica de bivalorações. Ambos corolários seguem por derivações no cálculo de Hilbert utilizando o recém-provado teorema da dedução.

        \subsection{Soundness.v}
        
        Este arquivo implementa as provas desenvolvidas ao longo da Seção~\ref{sec:cor}, necessárias para desenvolver o metateorema da correção.
        \begin{lstlisting}[name=Soundness, frame=single, language=coq]
(* Function used to prove $\Gamma$ $\vDash$m $\alpha$ -> $\Gamma$ $\vDash$ $\alpha$ *)
Definition h_formula ($\alpha$ : Formula) (v : Formula -> BivaluationDomain) : MatrixDomain :=
  match (v $\alpha$), (v $\neg$$\alpha$) with
  | $\top$, $\bot$ => One
  | $\top$, $\top$ => Half
  | $\bot$, _ => Zero
  end.

(* Proof that if v is a bivaluation, then h_formula is a valuation over the matrices i.e., h_formula is a homomorphism.
*)

Lemma h_valuation : forall (v : Formula -> BivaluationDomain),
bivaluation v -> valuation (fun x => h_formula x v).
Proof.
$\quad\vdots$
Qed.
        \end{lstlisting}

        A primeira definição feita é a da função \texttt{h\_formula} que constrói uma valoração sobre as matrizes a partir de uma bivaloração recebida como argumento, similar a função apresentada no Lema~\ref{lem:matval}. Na prova manual deste lema, o fato desta função ser uma valoração sobre as matrizes {--} um homomorfismo entre a linguagem e as matrizes {--} foi tomado como trivial. Para o Rocq, entretando, este fato não é imediato e deve ser demonstrado, o que é feito pelo lema \texttt{h\_valuation}, que segue por análise de caso nos valores de $v(\alpha)$ e $v(\neg \alpha)$ da função \texttt{h\_formula}.

        Depois disso, a prova do Lema~\ref{lem:matval} é desenvolvida.

        \begin{lstlisting}[name=Soundness, frame=single, language=coq]
Lemma bivaluation_matrix_lemma : forall (v : Formula -> BivaluationDomain),
bivaluation v -> 
(exists (h : Formula -> MatrixDomain),
  (forall $\phi$ : Formula, v $\phi$ = $\top$ <-> designatedValue (h $\phi$)) /\ valuation h).
Proof. 
$\quad\vdots$
Qed.

Corollary bivaluation_matrix_imp1 : forall ($\Gamma$ : Ensemble Formula) ($\alpha$ : Formula), 
($\Gamma$ $\vDash$m $\alpha$) -> ($\Gamma$ $\vDash$ $\alpha$).
Proof.
$\quad\vdots$
Qed.
        \end{lstlisting}

        O lema \texttt{bivaluation\_matrix\_lemma} segue por análise de caso em $v(\phi)$ e $v(\neg \phi)$, utilizando a valoração obtida ao aplicar a função \texttt{h\_formula} em $v$ e o resultado obtido no lema \texttt{h\_valuation}. Com este resultado, a prova da ida da equivalência entre os sistemas semânticos é desenvolvida em \texttt{bivaluation\_matrix\_imp1}, utilizando as definições de 