\chapter{Implementação em Rocq}\label{cap:implementacao}

Neste capítulo será descrita a implementação da biblioteca da lógica de inconsistência formal \lfium{} no assistente de provas Rocq (anteriormente conhecido como Coq), bem como o desenvolvimento de alguns metateoremas apresentados na Seção~\ref{sec:metateoremas} dentro da biblioteca. A implementação será análoga àquela feita por~\citeshort{silveira2020implementacao}, que implementou uma biblioteca de lógica modal. Antes de tratar especificamente da implementação, o Rocq será brevemente apresentado e caracterizado.

\section{Assistente de provas Rocq}\label{sec:rocq}
    Os assistentes de provas são ferramentas de \textit{software} que auxiliam o usuário no desenvolvimento de teoremas, permitindo que provas sejam verificadas na medida em que são escritas~\cite{geuvers2009proof}, conferindo a estes programas uma importância significativa na verificação e especificação formal de \textit{software}. Atualmente, existem diversos assistentes de provas como: Agda, Isabelle, Rocq, Lean, HOL, Idris e Twelf. Cada um destes tem suas particularidades e diferenças em relação ao formalismo matemático utilizado como base.

    O Rocq é um assistente de provas baseado no Cálculo de Construções Indutivas (CCI) que possui aplicações em diferentes áreas da matemática e da computação como (mas não limitado a) lógica, linguagens formais, linguística computacional e desenvolvimento de programas seguros~\cite{coqart}. Sob a ótica da Correspondência de Curry{-}Howard, o Rocq é tanto uma linguagem de programação funcional quanto uma linguagem de prova, podendo ser dividido em quatro partes~\cite{silva2019certificaccao}:
    
    \begin{itemize}
        \item A linguagem de programação e especificação \textit{Gallina}, que goza da propriedade da normalização forte\footnote{Um termo-$\lambda$ é fortemente normalizável caso toda sequência de reescrita acabe numa forma normal (num termo irredutível). Um sistema no qual todos os termos-$\lambda$ são fortemente normalizáveis possui a propriedade da normalização forte~\cite{nipkow2006rewriting}.}, a qual garante que todo programa termina.
        \item A linguagem de comandos \textit{Vernacular}, que permite interagir com o assistente.
        \item O conjunto de táticas (\textit{tactics}) utilizadas para manipular elementos durante o desenvolvimento de uma prova.
        \item A linguagem $\pazocal{L}$tac, utilizada para implementar novas táticas e automatizar provas.
    \end{itemize}

    No restante desse trabalho, conceitos básicos sobre o funcionamento do assistente de provas Rocq e sobre seu uso no desenvolvimento de provas e verificação de provas não serão apresentados em grandes detalhes. Ao leitor interessado em tais assuntos, é recomendada uma consulta aos trabalhos de~\citeshort{Pierce2017Logical} e~\citeshort{silveira2020implementacao}.

\section{Biblioteca em Rocq}
    Nesta seção será apresentada a biblioteca para a lógica \lfium{}, com todos os artefatos semânticos e sintáticos apresentados ao longo do trabalho, bem como provas para os metateoremas manualmente provados. A biblioteca foi desenvolvida utilizando a versão 9.0.0 do Rocq e está disponível em \url{https://github.com/dipled/LFI1_Library}.

    Primeiro, algumas notações, definições e propriedades úteis foram estabelecidas para facilitar a implementação.

    \begin{lstlisting}[name=Utils, numbers=left, frame=single, language=coq]
Require Import Arith Constructive_sets.

Arguments In {U}.
Arguments Add {U}.
Arguments Empty_set {U}.
Arguments Union {U}.
Arguments Included {U}.
Arguments Singleton {U}.
Arguments Complement {U}.

Notation " a $\in$ A " := (In A a) (at level 10).
Notation " a $\not \in$ A " := (~In A a) (at level 10).
Notation " B $\cup$ C " := (Union B C) (at level 48, left associativity).
Notation " [ a ] " := (Singleton a) (at level 0, right associativity).
Notation " A $\subseteq$ B " := (Included A B) (at level 71). 
Notation " $\varnothing$ "     := (Empty_set).
    \end{lstlisting}

    As bibliotecas \texttt{Arith} e \texttt{Constructive\_sets} fornecem alguns teoremas e definições fundamentais para trabalhar com conjuntos em Rocq, na forma de estruturas chamadas de \texttt{Ensembles}, que são mapeamentos de um tipo qualquer \texttt{U} para \texttt{Prop}. A fim de facilitar a leitura do código, as linhas 11 a 16 estabelecem notações para conceitos de pertinência, união e contingência de conjuntos e conjuntos vazio e \textit{singleton}.

    \begin{lstlisting}[name=Utils, numbers=left, frame=single, language=coq]
Theorem iff_neg : forall A B : Prop, (A <-> B) -> (~A <-> ~B).
Proof.
  intros. split; intros; intro; apply H0; apply H; apply H1.
Qed.

Theorem contra : forall A B : Prop, (A -> B) -> (~B -> ~A).
Proof.
  intros. intro. apply H0. apply H. apply H1.
Qed. 

Ltac destruct_conjunction H :=
match type of H with
| _ /\ _ => 
  let L := fresh "L" in
  let R := fresh "R" in
  destruct H as [L R]; destruct_conjunction L; destruct_conjunction R
| _ => idtac
end.
    \end{lstlisting}

    O $\pazocal{L}$tac  \texttt{destruct\_conjunction} é uma tática que recebe como argumento uma hipótese \texttt{H} e caso esta hipótese seja uma conjunção, ela é destruída em duas novas hipóteses \texttt{L} e \texttt{R} e a tática é repetida recursivamente para cada uma destas hipóteses.