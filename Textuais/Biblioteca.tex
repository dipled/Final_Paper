\chapter{Implementação em Rocq}\label{cap:implementacao}

Neste capítulo será descrita a implementação da biblioteca da lógica de inconsistência formal \lfium{} no assistente de provas Rocq (anteriormente conhecido como Coq), bem como o desenvolvimento de alguns metateoremas apresentados na Seção~\ref{sec:metateoremas} dentro da biblioteca. A implementação será análoga àquela feita por~\citeshort{silveira2020implementacao}, que implementou uma biblioteca de lógica modal. Antes de tratar especificamente da implementação, o Rocq será brevemente apresentado e caracterizado.

\section{Assistente de provas Rocq}\label{sec:rocq}
    Os assistentes de provas são ferramentas de \textit{software} que auxiliam o usuário no desenvolvimento de teoremas, permitindo que provas sejam verificadas na medida em que são escritas~\cite{geuvers2009proof}, conferindo a estes programas uma importância significativa na verificação e especificação formal de \textit{software}. Atualmente, existem diversos assistentes de provas como: Agda, Isabelle, Rocq, Lean, HOL, Idris e Twelf. Cada um destes tem suas particularidades e diferenças em relação ao formalismo matemático utilizado como base.

    O Rocq é um assistente de provas baseado no Cálculo de Construções Indutivas (CCI) que possui aplicações em diferentes áreas da matemática e da computação como (mas não limitado a) lógica, linguagens formais, linguística computacional e desenvolvimento de programas seguros~\cite{coqart}. Sob a ótica da Correspondência de Curry{-}Howard, o Rocq é tanto uma linguagem de programação funcional quanto uma linguagem de prova, podendo ser dividido em quatro partes~\cite{silva2019certificaccao}:
    
    \begin{itemize}
        \item A linguagem de programação e especificação \textit{Gallina}, que goza da propriedade da normalização forte\footnote{Um termo-$\lambda$ é fortemente normalizável caso toda sequência de reescrita acabe numa forma normal (num termo irredutível). Um sistema no qual todos os termos-$\lambda$ são fortemente normalizáveis possui a propriedade da normalização forte~\cite{nipkow2006rewriting}.}, a qual garante que todo programa termina.
        \item A linguagem de comandos \textit{Vernacular}, que permite interagir com o assistente.
        \item O conjunto de táticas (\textit{tactics}) utilizadas para manipular elementos durante o desenvolvimento de uma prova.
        \item A linguagem $\pazocal{L}$tac, utilizada para implementar novas táticas e automatizar provas.
    \end{itemize}

    No restante desse trabalho, conceitos básicos sobre o funcionamento do assistente de provas Rocq e sobre seu uso no desenvolvimento de provas e verificação de provas não serão apresentados em grandes detalhes. Ao leitor interessado em tais assuntos, é recomendada uma consulta aos trabalhos de~\citeshort{Pierce2017Logical} e~\citeshort{silveira2020implementacao}.

\section{Biblioteca em Rocq}\label{sec:biblioteca}
    Nesta seção será apresentada a biblioteca para a lógica \lfium{}, com os principais artefatos semânticos e sintáticos apresentados ao longo do trabalho, bem como provas para os metateoremas manualmente provados. A biblioteca foi desenvolvida utilizando a versão 9.0.0 do Rocq e está disponível em \url{https://github.com/dipled/LFI1_Library}. Cada subseção representa um arquivo da biblioteca e as partes mais importantes de cada um destes será comentada ao longo do texto.

    \subsection{Utils.v}\label{sec:utils}

      Este arquivo contem algumas notações, definições e propriedades úteis que foram estabelecidas para facilitar a implementação.

      \begin{lstlisting}[name=Utils, frame=single, language=coq]
Require Import Arith Constructive_sets.
$\qquad\vdots$
Notation " a $\in$ A " := (In A a) (at level 10).
Notation " a $\not \in$ A " := (~In A a) (at level 10).
Notation " B $\cup$ C " := (Union B C) (at level 48, left associativity).
Notation " [ a ] " := (Singleton a) (at level 0, right associativity).
Notation " A $\subseteq$ B " := (Included A B) (at level 71). 
Notation " $\varnothing$ "     := (Empty_set).
      \end{lstlisting}

      As bibliotecas \texttt{Arith} e \texttt{Constructive\_sets} fornecem alguns teoremas e definições fundamentais para trabalhar com conjuntos em Rocq, na forma de estruturas chamadas de \texttt{Ensembles}, que são mapeamentos de um tipo qualquer \texttt{U} para \texttt{Prop}. A fim de facilitar a leitura do código, foram estabelecidas notações para conceitos de pertinência, união e contingência de conjuntos e conjuntos vazio e \textit{singleton}.

      \begin{lstlisting}[name=Utils, frame=single, language=coq]
Theorem iff_neg : forall A B : Prop, (A <-> B) -> (~A <-> ~B).
$\qquad\vdots$
Theorem contra : forall A B : Prop, (A -> B) -> (~B -> ~A).
$\qquad\vdots$
Ltac destruct_conjunction H :=
match type of H with
| _ /\ _ => 
  let L := fresh "L" in
  let R := fresh "R" in
  destruct H as [L R]; destruct_conjunction L; destruct_conjunction R
| _ => idtac
end.
      \end{lstlisting}

      O $\pazocal{L}$tac  \texttt{destruct\_conjunction} é uma tática que recebe como argumento uma hipótese \texttt{H} e caso esta hipótese seja uma conjunção, ela é destruída em duas novas hipóteses \texttt{L} e \texttt{R} e a tática é repetida recursivamente para cada uma destas hipóteses.

      \subsection{Language.v}\label{sec:language}

      Este arquivo contem a definição da linguagem da \lfium{}, como apresentada na Seção~\ref{sec:linguagem}.

      \begin{lstlisting}[name=Language, frame=single, language=coq]
Require Import LFI1.Utils.
From Stdlib Require Import Arith Constructive_sets.

Definition Atom := nat.

Inductive Formula : Set :=
  | Lit    : Atom -> Formula
  | Neg    : Formula -> Formula
  | And    : Formula -> Formula -> Formula
  | Or     : Formula -> Formula -> Formula
  | Imp    : Formula -> Formula -> Formula
  | Consistency   : Formula -> Formula.

Notation " x $\to$ y " := 
(Imp x y) (at level 8, right associativity).

Notation " x $\land$ y " := 
(And x y) (at level 6, left associativity).

Notation " x $\lor$ y " := 
(Or x y) (at level 7, left associativity).

Notation " $\neg$ x " := 
(Neg x) (at level 5, right associativity, format "\neg x").

Notation " $\circ$ x " := 
(Consistency x) (at level 5, right associativity, format "$\circ$ x").

Notation " $\#$ x " :=
(Lit x) (at level 2, no associativity, x constr at level 1, format "$\#$ x").
      \end{lstlisting}
      
      Note que \texttt{Lit} é construído a partir de um \texttt{Atom}, que por sua vez é só um \textit{alias} para o tipo \texttt{nat} (um número natural), portanto o tipo \textit{Formula} é enumerável.

    \subsection{Syntax.v}\label{sec:syntax}

      Este arquivo contem a definição da sintaxe da \lfium{}, através do cáclulo de Hilbert definido na Seção~\ref{sec:axiomatizacao}.

      \begin{lstlisting}[name=Syntax, frame=single, language=coq]
Require Import LFI1.Utils LFI1.Language.
From Stdlib Require Import Arith Constructive_sets.

(* Hilbert calculus: *)

Inductive Ax : Set :=
  | Ax1      : Formula -> Formula -> Ax
  | Ax2      : Formula -> Formula -> Formula -> Ax
$\qquad\vdots$
  | bc1      : Formula -> Formula -> Ax
  | cf       : Formula -> Ax
  | ce       : Formula -> Ax
  | ci       : Formula -> Ax
$\qquad\vdots$
Definition instantiate (a : Ax) : Formula :=
  match a with 
  | Ax1 $\alpha$ $\beta$      => $\alpha$ $\to$ ($\beta$ $\to$ $\alpha$)
  | Ax2 $\alpha$ $\beta$ $\gamma$    => ($\alpha$ $\to$ ($\beta$ $\to$ $\gamma$)) $\to$ (($\alpha$ $\to$ $\beta$) $\to$ ($\alpha$ $\to$ $\gamma$))
$\qquad\vdots$
  | bc1 $\alpha$ $\beta$      => $\circ$$\alpha$ $\to$ ($\alpha$ $\to$ ($\neg$$\alpha$ $\to$ $\beta$))
  | cf $\alpha$         => $\neg$$\neg$$\alpha$ $\to$ $\alpha$
  | ce $\alpha$         => $\alpha$ $\to$ $\neg$$\neg$$\alpha$
  | ci $\alpha$         => $\neg$$\circ$$\alpha$ $\to$ ($\alpha$ $\land$ $\neg$ $\alpha$)
$\qquad\vdots$
  end.
  
Inductive deduction : Ensemble Formula -> Formula -> Prop :=
  | Premisse : forall ($\Gamma$ : Ensemble Formula) ($\phi$ : Formula), $\phi$ $\in$ $\Gamma$ -> deduction $\Gamma$ $\phi$
  | AxiomInstance : forall ($\Gamma$ : Ensemble Formula) (a : Ax), deduction $\Gamma$ (instantiate a)
  | MP : forall ($\Gamma$ : Ensemble Formula) ($\phi$ $\psi$ : Formula), (deduction $\Gamma$ ($\phi$ $\to$ $\psi$)) -> 
    (deduction $\Gamma$ $\phi$) -> deduction $\Gamma$ $\psi$.

Notation " $\Gamma$ $\vdash$ $\phi$ " := (deduction $\Gamma$ $\phi$) (at level 50, no associativity).
      \end{lstlisting}

      Primeiro, o tipo \texttt{Ax} foi definido como um tipo indutivo (também chamado de tipo algébrico), com construtores que recebem como argumentos fórmulas correspondentes ao número de fórmulas dos axiomas definidos na Definição~\ref{def:hilbert_lfi1}. 
      
      Depois, a função \texttt{instantiate} é definida. Ela recebe como argumento um axioma (que por sua vez foi construído a partir de fórmulas) e retorna uma formula correspondente àquela representada pelo axioma, por exemplo, o axioma~\ref{ax:axcf} representa a eliminação da dupla negação, portanto, a função \texttt{instantiate} receberia um dado \texttt{cf $\alpha$} do tipo \texttt{Ax}, onde $\alpha$ é uma fórmula qualquer da linguagem, e retornaria um dado $\neg\neg\alpha \to \alpha$ do tipo \texttt{Formula}.

      Finalmente, o tipo \texttt{deduction} é definido indutivamente a partir de um conjunto de fórmulas (conjunto de premissas) e uma fórmula (conclusão) e retornando um dado do tipo \texttt{Prop} referente a possibilidade de construir uma derivação da conclusão a partir do conjunto de premissas, aplicando uma sequência de construtores, que representam os três casos de derivação descritos na Definição~\ref{def:derivacao}. O construtor \texttt{Premisse} diz que se uma fórmula qualquer pertence ao conjunto de premissas, então ela é derivável a partir deste conjunto. O construtor \texttt{AxiomInstance} diz que um axioma é sempre derivável a partir de qualquer conjunto de premissas. O construtor \texttt{MP} diz que, dadas duas fórmulas $\phi$ e $\psi$ quaisquer, se for possível derivar $\phi \to \psi$ e $\phi$ a partir de um conjunto de fórmulas, então podemos derivar $\psi$ a partir deste mesmo conjunto. Por último, uma notação com o operador infixo $\vdash$ é estabelecida para facilitar a leitura de derivações.
    
    \subsection{Semantics.v}

      Este arquivo contem a definição dos dois sistemas semânticos apresentados na Seção~\ref{sec:semantica}.

      O primeiro sistema definido foi a semântica matricial, conforme as Definições~\ref{def:mat} e~\ref{def:conmat}.
      \begin{lstlisting}[name=Semantics, frame=single, language=coq]
Require Import LFI1.Utils LFI1.Language.
From Stdlib Require Import Arith Constructive_sets.

(* Matrix Semantics: *)

Inductive MatrixDomain : Set :=
  | One
  | Half
  | Zero.

Definition designatedValue (a : MatrixDomain) : Prop :=
  match a with
  | Zero => False
  | _ => True
  end.

Definition andM (a b : MatrixDomain) : MatrixDomain :=
  match a, b with
  | Zero, _  => Zero
  | _, Zero  => Zero
  | One, One => One
  | _, _     => Half
  end.

Definition orM (a b : MatrixDomain) : MatrixDomain :=
  match a, b with
  | One, _     => One
  | _, One     => One
  | Zero, Zero => Zero
  | _, _       => Half
  end.

Definition impM (a b : MatrixDomain) : MatrixDomain :=
  match a, b with
  | Zero, _ => One
  | _, One  => One
  | _, Half => Half

  | _, Zero => Zero
  end.

Definition negM (a : MatrixDomain) : MatrixDomain :=
  match a with
  | One  => Zero
  | Half => Half
  | Zero => One
  end.

Definition consM (a : MatrixDomain) : MatrixDomain :=
  match a with
  | Half => Zero
  | _    => One
  end.

Notation " x $\to_{m}$ y " := 
(impM x y) (at level 21, right associativity).

Notation " x $\land_{m}$ y " := 
(andM x y) (at level 20, left associativity).

Notation " x $\lor_{m}$ y " := 
(orM x y) (at level 22, left associativity).

Notation " $\neg_{m}$ x " := 
(negM x) (at level 9, right associativity, format "$\neg_{m}$ x").

Notation " $\circ_{m}$ x " := 
(consM x) (at level 9, right associativity, format "$\circ_{m}$ x").
        
      \end{lstlisting}
      Note que \texttt{designatedValue} é um predicado sobre o domínio da matriz lógica, e retorna um \texttt{Prop} referente a pertinência de um dado valor ao conjunto $\{1,\meio{}\}$.

      Após definir a matriz lógica, é preciso estabelecer a noção de valorações sobre essa matriz, conforme apresentada na Definição~\ref{def:matlog}, que define valoração como um homomorfismo entre linguagem e a álgebra da matriz, preservando a estrutura dos seus operadores.
    
      \begin{lstlisting}[name=Semantics, frame=single, language=coq]
(* Defining the conditions for a function to be a valuation over the matrix,
i.e., it must be a homomorphism from Formula to MatrixDomain.
*)

Definition preserveAnd (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$ $\psi$: Formula, (v ($\phi$ $\land$ $\psi$)) = (v $\phi$) $\land_{m}$ (v $\psi$).

Definition preserveOr (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$ $\psi$: Formula, (v ($\phi$ $\lor$ $\psi$)) = (v $\phi$) $\lor_{m}$ (v $\psi$).

Definition preserveTo (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$ $\psi$: Formula, (v ($\phi$ $\to$ $\psi$)) = (v $\phi$) $\to_{m}$ (v $\psi$).

Definition preserveNeg (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$: Formula, (v ($\neg$$\phi$)) = $\neg_{m}$(v $\phi$).

Definition preserveCirc (v : Formula -> MatrixDomain) : Prop := 
forall $\phi$: Formula, (v ($\circ$$\phi$)) = $\circ_{m}$(v $\phi$).

Definition valuation (v : Formula -> MatrixDomain) : Prop :=
preserveOr v /\ preserveTo v /\ preserveAnd v /\ preserveNeg v /\ preserveCirc v.

(* Defining the semantic consequence relation w.r.t matrices *)
Definition matrixEntails ($\Gamma$ : Ensemble Formula) ($\phi$ : Formula) := 
forall v : (Formula -> MatrixDomain),
valuation v -> 
(forall ($\psi$: Formula), 
  $\psi$ $\in$ $\Gamma$ -> designatedValue (v $\psi$)) -> 
    designatedValue (v $\phi$).

Notation " $\Gamma$ $\vDash$m $\phi$ " := (matrixEntails $\Gamma$ $\phi$) (at level 50, no associativity).
      \end{lstlisting}

      A definição \texttt{valuation} representa um predicado sobre qualquer mapeamento de \texttt{Formula} para \texttt{MatrixDomain}, que retorna \texttt{True} caso este mapeamento seja um homomorfismo sobre a linguagem e o domínio da matriz e retorna \texttt{False} caso contrário. A relação de consequência semântica é definida em \texttt{matrixEntails} (conforme a Definição~\ref{def:conmat}), que diz que, dado um conjunto de fórmulas (conjunto de premissas) e uma fórmula (conclusão), esta fórmula será uma consequência semântica do conjunto de premissas caso toda valoração que satisfaz todas as fórmulas deste conjunto também satisfizer a conclusão.