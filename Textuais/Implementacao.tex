\chapter{Implementação}
    \label{cap:Implementacao}
	  Os desenvolvimentos deste trabalho são baseados numa biblioteca em Coq versão 8.15.2 desenvolvida em~\citeshort{silveira2020implementacao} e~\citeshort{silveira2022sound},
    que se encontra disponível em \url{https://github.com/funcao/LML/tree/master/coq}.
	  A modelagem de lógica modal em Coq destes trabalhos é característica de um \textit{deep embedding} este que, segundo~\citeshort{azurat2002survey},
	  é uma forma de modelar um sistema lógico \Mathcali{L}{0} dentro de outro sistema lógico \Mathcali{L}{1} representando completamente a
	  sintaxe e semântica de \Mathcali{L}{0}.

    Neste capítulo, será apresentada a biblioteca base sobre onde os desenvolvimentos deste trabalho foram feitos
	  e os próprios desenvolvimentos serão descritos. Na Seção~\ref{sec:ImplementacaoCoq} será descrita a biblioteca de lógica modal que
    serviu de base para este trabalho, na Seção~\ref{sec:SistemaKT4Coq} será descrita a modelagem do sistema
    multimodal \SisT na biblioteca e na Seção~\ref{sec:MultimodaisCoq} será descrita a modelagem genérica de lógicas multimodais na biblioteca.

    \section{A Biblioteca em Coq}
        \label{sec:ImplementacaoCoq}
        A biblioteca é dividida em nove arquivos, dos quais oito são referentes a alguma parte da modelagem de lógica modal e um apresenta
        exemplo de uso da biblioteca.
        O arquivo \texttt{Modal\_Library.v} apresenta as principais definições da biblioteca, como a definição de fórmulas
        da lógica modal, frames, modelos, valoração de fórmulas, consequência semântica e provas de diversas propriedades
        da consequência semântica.
        Fórmulas da lógica modal são representadas como tipo indutivo dentro do \textit{sort Set}, frames e modelos são representados
        como estruturas do tipo \textit{Record}, como descrito a seguir:
        \begin{lstlisting}[language=coq]
    Inductive formula: Set :=
      | Lit    : nat -> formula
      | Neg    : formula -> formula
      | Box    : formula -> formula
      | Dia    : formula -> formula
      | And    : formula -> formula -> formula
      | Or     : formula -> formula -> formula
      | Implies: formula -> formula -> formula.
    Record Frame: Type := {
      W: Set;
      R: W -> W -> Prop
    }.
    Record Model: Type := {
      F: Frame;
      v: nat -> (W F) -> Prop
    }.
        \end{lstlisting}

        Para construir um frame ou modelo são usados os construtores \texttt{Build\_Frame} e \texttt{Build\_Model}, respectivamente.
        O arquivo \texttt{Modal\_Notations.v} descreve uma notação para representar fórmulas da lógica modal e operações sobre fórmulas
        dentro do Coq de maneira mais conveniente. Por exemplo, uma fórmula como:
        \[
            (p_0 \lor p_1) \to (p_0 \land \neg p_2) \to (\Box p_0 \to \Diamond p_1)
        \]
        é representada dentro da biblioteca como (note os delimitadores):
        \begin{lstlisting}[basicstyle=\ttfamily,columns=fullflexible]
    [! (#0 \/ #1) -> (#0 /\ ~ #2) -> ([] #0 -> <> #1) !]
        \end{lstlisting}

        O arquivo \texttt{Logical\_Equivalence.v} apresenta diversas provas de equivalências lógicas da lógica modal, por exemplo, provando
        a dualidade entre \BOX e \DIA. O arquivo \texttt{Modal\_Tactics.v} apresenta provas de diversos resultados úteis para desenvolver
        provas mais complexas. O arquivo \texttt{Frame\_Validation.v} apresenta provas de corretude de frames, isto é, prova que
        se um frame respeita uma dada propriedade então o axioma correspondente desta propriedade será válido naquele frame e
        que se o axioma correspondente de uma propriedade for válido em um frame então este frame respeitará aquela propriedade.

        O arquivo \texttt{Deductive\_System.v} descreve o sistema axiomático de Hilbert para a lógica modal, onde axiomas são representados
        como um tipo indutivo dentro do \textit{sort Set}, instâncias de axiomas são obtidas por meio de uma função de instanciação e
        deduções são representadas por uma relação definida indutivamente, como apresentado a seguir:
        \begin{lstlisting}[language=coq]
    Inductive axiom : Set :=
      | ax1   : formula -> formula -> axiom
      | ax2   : formula -> formula -> formula -> axiom
      (* algumas linhas foram omitidas *)
      | axK   : formula -> formula -> axiom
      | axPos : formula -> formula -> axiom
      (* algumas linhas foram omitidas *)
      | axGL  : formula -> axiom.
    Definition instantiate (a: axiom): formula :=
      match a with
      | ax1   f0 f1   => [! f0 -> (f1 -> f0) !]
      | ax2   f0 f1 f2 => [! (f0 -> (f1 -> f2)) -> ((f0 -> f1) -> (f0 -> f2)) !]
      (* algumas linhas foram omitidas *)
      | axK   f0 f1   => [! [](f0 -> f1) -> ([] f0 -> [] f1) !]
      | axPos f0 f1   => [! <> (f0 \/ f1) -> (<> f0 \/ <> f1) !]
      (* algumas linhas foram omitidas *)
      | axGL  f0     => [! []([]f0 -> f0) -> []f0 !]
      end.
    Inductive deduction (A: axiom -> Prop): theory -> formula -> Prop :=
      | Prem: forall (t: theory) (f: formula) (i: nat),
              (nth_error t i = Some f) -> deduction A t f
      | Ax: forall (t: theory) (a: axiom) (f: formula),
            A a -> instantiate a = f -> deduction A t f
      | Mp: forall (t: theory) (f g: formula) (d1: deduction A t [! f -> g !])
                   (d2: deduction A t f), deduction A t g
      | Nec: forall (t: theory) (f: formula) (d1: deduction A t f),
             deduction A t [! []f !].
        \end{lstlisting}

        Os arquivos \texttt{Soundness.v} e \texttt{Completeness.v} apresentam provas de corretude e completude para a lógica modal,
        respectivamente. Para a prova de corretude, é provado que todos os axiomas do sistema de Hilbert são tautologias da lógica modal
        e que as regras de \textit{Modus Ponens} e Necessitação preservam validade de fórmulas. Já para a prova de completude, é
        definido como construir conjuntos de Lindenbaum para então construir conjuntos maximais consistentes, porém, até o momento
        da escrita deste trabalho, a prova de completude não foi terminada.

    % texorpdfstring serve para suprimir um erro que surgiria se deixasse apenas o \SisT no título da seção
    % o erro é devido as bookmarks do pdf, que não permitem caracteres especiais
	  \section{O Sistema Bimodal \texorpdfstring{\SisT}{KT . K4} em Coq}
      \label{sec:SistemaKT4Coq}
      Para este trabalho, foi modelado em Coq versão 8.15.2 o sistema bimodal \SisT, descrito formalmente na Seção~\ref{sec:SistemaKT4}, como prova de conceito
      da possibilidade de modelar lógicas multimodais na biblioteca descrita anteriormente neste capítulo.
      O sistema foi implementado em três arquivos distintos que modelam, respectivamente, os componentes básicos do sistema (linguagem, frames e modelos, sistema axiomático),
      as propriedades semânticas do sistema (da valoração em mundos/modelos e da consequência semântica) e as propriedades sintáticas do sistema (da relação de consequência sintática).
      % (linguagem, frames, modelos, valoração, definição de regras de consequência semântica, sistema axiomático, notação e formas de traduzir fórmulas/axiomas
      % da biblioteca base para )

      O código desenvolvido seguiu os padrões de nomenclatura e estilo da biblioteca base, com o intuito de tornar
      este o mais próximo possível do que já foi desenvolvido. O código desenvolvido encontra-se disponível em: \url{https://github.com/funcao/LML/tree/Fusao}.

      Para esta implementação, foram feitos vários pares de definições/funções/teoremas para representar certas propriedades sobre o sistema \SisT com respeito aos sistemas
      \textbf{KT} e \textbf{K4}, pares estes que são essencialmente iguais, portanto, em casos onde não for estritamente necessário apresentar os dois elementos de um par, será apresentado
      apenas um para evitar repetições desnecessárias. Para representar fórmulas da linguagem do sistema \SisT, foi necessário definir um tipo indutivo novo,
      análogo ao tipo das fórmulas para a linguagem modal básica, como apresentado a seguir:

      \begin{lstlisting}[language=coq]
    Inductive KT4formula : Set :=
      | T4Lit    : nat        -> KT4formula
      | T4Neg    : KT4formula -> KT4formula
      | TBox     : KT4formula -> KT4formula
      | TDia     : KT4formula -> KT4formula
      | K4Box    : KT4formula -> KT4formula
      | K4Dia    : KT4formula -> KT4formula
      | T4And    : KT4formula -> KT4formula -> KT4formula
      | T4Or     : KT4formula -> KT4formula -> KT4formula
      | T4Implies: KT4formula -> KT4formula -> KT4formula.
      \end{lstlisting}
      Não foi possível utilizar o tipo já definido de fórmulas, pois as fórmulas para \SisT contém duas modalidades distintas, já as fórmulas da lógica
      modal descritas na biblioteca básica contém apenas uma modalidade.

      É definida uma notação para fórmulas de forma análoga ao que foi feito na biblioteca base, onde uma fórmula:
      \[
        (p_0 \lor p_1) \to (p_0 \land \neg p_2) \to (\Box_{T} p_0 \to \Diamond_{4} p_1)
      \]
      é representada dentro da biblioteca como (note os delimitadores):
      \begin{lstlisting}[basicstyle=\ttfamily,columns=fullflexible]
    <! (#0 \/ #1) -> (#0 /\ ~ #2) -> ([T] #0 -> <4> #1) !>
      \end{lstlisting}

      Para definir frames e modelos de \SisT, foi necessário redefinir os conceitos de reflexividade e transitividade de relações pois, na biblioteca base,
      essas relações são definidas para frames com apenas uma relação de acessibilidade da seguinte forma:
      \begin{lstlisting}[language=coq]
    Definition reflexivity_frame (F: Frame): Prop :=
      forall w, R F w w.
    Definition transitivity_frame (F: Frame): Prop :=
      forall w0 w1 w2: W F, (R F w0 w1 /\ R F w1 w2) -> R F w0 w2.
      \end{lstlisting}
      O que não é compatível com o conceito de frames para \SisT, logo as seguintes definições foram feitas:

      \begin{lstlisting}[language=coq]
    Definition reflexive_rel (X: Set) (R: X -> X -> Prop): Prop :=
      forall w, R w w.
    Definition transitive_rel (X: Set) (R: X -> X -> Prop): Prop :=
      forall w0 w1 w2, (R w0 w1 /\ R w1 w2) -> R w0 w2.
      \end{lstlisting}
      E provadas corretas com as definições de anteriores, exclusivas para frames:

      \begin{lstlisting}[language=coq]
    Theorem refl_equivalence: forall F W R,
      F = Build_Frame W R ->
      reflexivity_frame F <-> reflexive_rel W R.
    Theorem trans_equivalence: forall F W R,
      F = Build_Frame W R ->
      transitivity_frame F <-> transitive_rel W R.
      \end{lstlisting}

      No trecho acima, a expressão \texttt{Build\_Frame W R} denota o construtor do \texttt{Record Frame} apresentado anteriormente na Seção~\ref{sec:ImplementacaoCoq}.
      Com estas definições é possível definir frames e modelos para \SisT:
      \begin{lstlisting}[language=coq]
    Record KT4Frame: Type := {
      WT4: Set;
      RT: WT4 -> WT4 -> Prop;
      RT_refl: reflexive_rel WT4 RT;
      R4: WT4 -> WT4 -> Prop;
      R4_trans: transitive_rel WT4 R4
    }.
    Record KT4Model: Type := {
      FT4: KT4Frame;
      VT4: nat -> (WT4 FT4) -> Prop
    }.
      \end{lstlisting}

      Também são dadas definições explícitas de frames e modelos para os sistemas \textbf{KT} e \textbf{K4}. É importante ressaltar que estes conceitos já
      existiam antes, mas de forma implícita:
      \begin{lstlisting}[language=coq]
    Definition KTFrame (F: Frame) := reflexivity_frame F.
    Definition KTModel (M: Model) := exists F v, M = [F -- v] /\ KTFrame F.

    Definition K4Frame (F: Frame) := transitivity_frame F.
    Definition K4Model (M: Model) := exists F v, M = [F -- v] /\ K4Frame F.
      \end{lstlisting}

      No trecho acima, a expressão \verb+[F -- v]+ é uma notação para o construtor \texttt{Build\_Model} do \texttt{Record Model} apresentado
      anteriormente na Seção~\ref{sec:ImplementacaoCoq}. É necessário provar que frames (ou modelos) para \SisT são extensões dos mesmos conceitos
      para \textbf{KT} e \textbf{K4}, para isso é necessário demonstrar como obter um frame (modelo) de \textbf{KT} (\textbf{K4})
      a partir de um frame (modelo) de \SisT. Isso é feito definindo funções que constroem frames (modelos) de \textbf{KT} (\textbf{K4}) com os
      componentes de um frame (modelo) de \SisT:

      \begin{lstlisting}[language=coq]
    Definition KT4_frame_into_KT (F: KT4Frame): Frame :=
      match F with
      | Build_KT4Frame  W  RT  RT_refl  _  _ => Build_Frame W RT
      end.
    Definition KT4_model_into_KT (M: KT4Model): Model :=
      match M with
      | Build_KT4Model (Build_KT4Frame  W  RT  _  R4  _  as F) V =>
        Build_Model (KT4_frame_into_KT F) V
      end.
      \end{lstlisting}
      E provando que estas funções são corretas, isto é, que de fato transformam frames de um tipo em frames do outro tipo:

      \begin{lstlisting}[language=coq]
    Theorem KT4_frame_into_KT_sound: forall F,
      KTFrame (KT4_frame_into_KT F).
    Theorem KT4_model_into_KT_sound: forall M,
      KTModel (KT4_model_into_KT M).
      \end{lstlisting}

      A valoração de fórmulas de \SisT é definida de forma análoga ao que foi definida para a biblioteca base:

      \begin{lstlisting}[language=coq]
    Fixpoint KT4eval (M: KT4Model) (w: WT4 (FT4 M)) (f: KT4formula): Prop :=
      match f with
        | T4Lit     x      => VT4 M x w
        | TBox      f1     => forall w', RT (FT4 M) w w' -> KT4eval M w' f1
        | TDia      f1     => exists w', RT (FT4 M) w w' /\ KT4eval M w' f1
        | K4Box     f1     => forall w', R4 (FT4 M) w w' -> KT4eval M w' f1
        | K4Dia     f1     => exists w', R4 (FT4 M) w w' /\ KT4eval M w' f1
        | T4Neg     f1     => ~KT4eval M w f1
        | T4And     f1 f2  => KT4eval M w f1 /\ KT4eval M w f2
        | T4Or      f1 f2  => KT4eval M w f1 \/ KT4eval M w f2
        | T4Implies f1 f2  => KT4eval M w f1 -> KT4eval M w f2
      end.
      \end{lstlisting}

      São definidas duas funções que transformam fórmulas da biblioteca básica para fórmulas de \SisT são elas \texttt{KTformula\_to\_KT4formula} e \texttt{K4formula\_to\_KT4formula},
      isso é importante para provar que certas propriedades que \textbf{KT} e \textbf{K4} respeitam também são respeitadas por \SisT. Também é provado que estas funções são injetivas:
      \begin{lstlisting}[language=coq]
    Theorem KTformula_to_KT4formula_injective: forall f1 f2,
      KTformula_to_KT4formula f1 = KTformula_to_KT4formula f2 ->
        f1 = f2.
      \end{lstlisting}

      Com a definição de valoração de fórmulas, é definido o conceito de validade em modelos, consequência semântica em um modelo e consequência semântica em todos os modelos,
      são provadas propriedades da valoração de fórmulas, das operações de validade e consequência em modelos e é provado que valoração de fórmulas (e validade e consequência)
      semântica em \SisT é uma generalização dos casos para \textbf{KT} e \textbf{K4}.
      \begin{lstlisting}[language=coq]
    Theorem KT_eval_generalization: forall W RT RT_refl R4 R4_trans V f,
      let FT4 := Build_KT4Frame W RT RT_refl R4 R4_trans in
      let MT4 := Build_KT4Model FT4 V in
      let M := KT4_model_into_KT MT4 in
      forall w, fun_validation M w f <->
      KT4eval MT4 w (KTformula_to_KT4formula f).
      \end{lstlisting}

      O sistema sintático de \SisT é definido com base num conjunto de axiomas, definido como um tipo indutivo, uma função que associa objetos deste tipo a fórmulas, de forma
      análoga ao que foi feito na biblioteca base e as regras de derivação do sistema de Hilbert são definidas como um tipo indutivo, tal qual na biblioteca base.
      \begin{lstlisting}[language=coq]
    Inductive KT4axiom : Set :=
      | KT4ax1    : KT4formula -> KT4formula -> KT4axiom
      (* algumas linhas foram omitidas *)
      | KT4axK_T  : KT4formula -> KT4formula -> KT4axiom
      | KT4axK_4  : KT4formula -> KT4formula -> KT4axiom
      | KT4axPos_T: KT4formula -> KT4formula -> KT4axiom
      | KT4axPos_4: KT4formula -> KT4formula -> KT4axiom
      | KT4axT    : KT4formula -> KT4axiom
      | KT4axK4   : KT4formula -> KT4axiom.

    Definition KT4instantiate (a: KT4axiom): KT4formula :=
      match a with
      | KT4ax1     f0 f1   => <! f0 -> (f1 -> f0) !>
      (* algumas linhas foram omitidas *)
      | KT4axK_T   f0 f1   => <! [T](f0 -> f1) -> ([T] f0 -> [T] f1) !>
      | KT4axK_4   f0 f1   => <! [4](f0 -> f1) -> ([4] f0 -> [4] f1) !>
      | KT4axPos_T f0 f1   => <! <T> (f0 \/ f1) -> (<T> f0 \/ <T> f1) !>
      | KT4axPos_4 f0 f1   => <! <4> (f0 \/ f1) -> (<4> f0 \/ <4> f1) !>
      | KT4axT     f0     => <! [T] f0 -> f0 !>
      | KT4axK4    f0     => <! [4] f0 -> [4][4] f0 !>
      end.
      \end{lstlisting}

      São provadas algumas propriedades adicionais da transformação de teorias dos sistemas \textbf{KT} e \textbf{K4} para o sistema \SisT e são provadas
      propriedades da derivação no sistema \SisT. Por fim, é provado que toda dedução nos sistemas \textbf{KT} / \textbf{K4} é possível de ser feita no sistema \SisT,
      por meio de predicados definidas indutivamente, que associam axiomas da biblioteca base para axiomas do sistema \SisT.
      \begin{lstlisting}[language=coq]
    Theorem KTdeduction_generalization: forall G f,
      let KT_to_KT4 := KTformula_to_KT4formula in
      deduction T G f -> KT4deduction KT4Ax (KT_theory_to_KT4theory G) (KT_to_KT4 f).
      \end{lstlisting}

      Por fim, é definido um predicado que descreve a corretude de um dado sistema axiomático com respeito a alguma classe de frames (representado como uma função de tipo
      \(\mathtt{Frame} \to \mathtt{Prop}\)), para então provar que, assumindo a corretude dos sistemas \textbf{KT} e \textbf{K4}, o sistema \SisT é correto, ou seja, provar
      a transferência da corretude para este caso particular de fusão.

      \begin{lstlisting}[language=coq]
    Definition relative_soundness (A: axiom -> Prop) (P: Frame -> Prop) :=
      forall G f, (A; G |-- f) -> forall F V, P F -> entails (Build_Model F V) G f.
      \end{lstlisting}
      Este predicado é provado correto com relação à definição de corretude para o sistema \textbf{K} da biblioteca base, onde o predicado indutivo \texttt{anyFrame} descreve a classe de todos os
      frames\footnote{Este predicado poderia ser substituído por uma função que recebe um frame e retorna \texttt{True} independente do frame.}:

      \begin{lstlisting}[language=coq]
    Inductive anyFrame (F: Frame): Prop := anyFrameMk: anyFrame F.

    Lemma relative_soundness_correct:
      relative_soundness K anyFrame <->
      (forall (G: theory) (f: formula), (K; G |-- f) -> (G ||= f)).
      \end{lstlisting}

        Com base nessa definição, foi provada a corretude dos sistemas \textbf{KT} e \textbf{K4}:
      \begin{lstlisting}[language=coq]
    Theorem KT_soundness:
      relative_soundness T reflexivity_frame.

    Theorem K4_soundness:
      relative_soundness K4 transitivity_frame.
      \end{lstlisting}

      Analogamente ao que foi feito anteriormente para o sistema \textbf{K}, foi definido um predicado que representa a corretude no sistema \SisT e uma função que descreve a
      classe de todo 2-frame reflexivo e transitivo:
      \begin{lstlisting}[language=coq]
    Inductive anyKT4Frame (F: KT4Frame): Prop := anyKT4FrameMk: anyKT4Frame F.

    Definition relative_KT4soundness (A: KT4axiom -> Prop) (R: KT4Frame -> Prop) :=
      forall G f, (A; G |--t4 f) -> forall F V, R F -> KT4entails (Build_KT4Model F V) G f.
      \end{lstlisting}

      Com essas definições, foi provada a corretude do sistema \SisT:
    \begin{lstlisting}[language=coq]
    Theorem KT4_soundness:
      relative_KT4soundness KT4Ax anyKT4Frame.
    \end{lstlisting}

      Porém não foi possível completar essa prova com base nas premissas de que \textbf{KT} e \textbf{K4} são corretos. Essas premissas não levaram a nenhuma
      contradição, porém elas também não contribuíram na prova pois, devido a maneira que foram definidos os conceitos de consequência sintática e semântica e
      como as interpretações destes conceitos na biblioteca base e na prova de conceito foram relacionados, as premissas de que \textbf{KT} e \textbf{K4} são corretos geram
      outras premissas inúteis. A prova da corretude de \SisT foi feita provando (com grande auxílio das ferramentas de automação do Coq)
      cada caso da prova ``manualmente'', independente da hipótese de corretude de \textbf{KT} e \textbf{K4}.

    \section{Lógicas Multimodais}
      \label{sec:MultimodaisCoq}
      A segunda parte da implementação deste trabalho consiste na modelagem em Coq versão 8.15.2 de lógicas multimodais, descritas formalmente na Seção~\ref{sec:LM-Multimodais}, também usando
      como base a biblioteca de lógica modal descrita anteriormente neste capítulo.
      Este sistema foi modelado em cinco arquivos distintos, dos quais quatro representam componentes de fato do sistema multimodal e um descreve exemplos de aplicação.
      Assim como na modelagem do sistema \SisT, o código desenvolvido seguiu os padrões de nomenclatura e estilo da biblioteca base e encontra-se disponível em:
      \url{https://github.com/funcao/LML/tree/Fusao}.

      Inicialmente, fórmulas da linguagem multimodal foram modeladas como um tipo indutivo de maneira semelhante ao que foi feito na biblioteca base e na modelagem do sistema
      \SisT, porém a principal diferença entre a modelagem aqui descrita e as outras modelagens é que as fórmulas da linguagem multimodal que contém modalidades recebem um
      argumento adicional, que indica o índice da modalidade:

      \begin{lstlisting}[language=coq]
    Inductive MMformula : Set :=
      | MMLit    : nat           -> MMformula
      | MMNeg    : MMformula     -> MMformula
      | MMBox    : nat           -> MMformula -> MMformula
      | MMDia    : nat           -> MMformula -> MMformula
      | MMAnd    : MMformula     -> MMformula -> MMformula
      | MMOr     : MMformula     -> MMformula -> MMformula
      | MMImplies: MMformula     -> MMformula -> MMformula.
      \end{lstlisting}

      A notação para fórmulas definida na prova de conceito é reaproveitada nesta seção, onde uma fórmula como:
      \[
        (p_0 \lor p_1) \to (p_0 \land \neg p_2) \to (\Box_{0} p_0 \to \Diamond_{3} p_1)
      \]
      É representada dentro da biblioteca como\footnote{Não foi possível representar a modalidade \DIAi{x} apenas por \texttt{<x>} pois a notação ``? < x'', onde x é um natural,
      é reservada para a operação de menor, que está definida na biblioteca padrão e portanto não pode ser sobrecarregada sem antes realizar outras alterações.}:
      \begin{lstlisting}[basicstyle=\ttfamily,columns=fullflexible]
    <! (#0 \/ #1) -> (#0 /\ ~ #2) -> ([0] #0 -> <<3>> #1) !>
      \end{lstlisting}

      Note que esta definição indutiva não representa de fato a união das assinaturas de duas linguagens distintas, ou seja, não representa precisamente a definição de linguagens multimodais
      como foi descrito na Definição~\ref{def:Fusao}. Mais será comentado sobre isso na Seção~\ref{sec:Dificuldades}.

      Há dois motivos por trás da representação de modalidades com um índice: permitir que um único tipo indutivo seja capaz de representar fórmulas de qualquer sistema multimodal,
      independente de quantas modalidades ele tenha e garantir que uma fórmula (leia-se, um objeto que habita o tipo \texttt{MMformula}) não precise de alguma prova para ser construída,
      ou seja, não é necessário fornecer uma prova que o índice da modalidade de uma fórmula é menor que o número de modalidades num dado sistema modal para então poder construir uma fórmula.
      Porém, essa escolha carrega um problema: como garantir que, em um sistema multimodal com \textit{n} modalidades, não seja possível operar sobre fórmulas que contenham modalidades cujo
      índice é maior que \textit{n}?

      Para resolver este problema foi utilizado o mecanismo de seções do Coq com o intuito de definir uma variável que representa a quantidade de modalidades em um dado sistema multimodal,
      assim como uma restrição de que há mais de uma modalidade no sistema multimodal.

      \begin{lstlisting}[language=coq]
    Section MultiModal.
      Variable Modalities: nat.
      Hypothesis minimum_modalities: Modalities > 1.
      (* ... *)
    End MultiModal.
      \end{lstlisting}
      A definição dessa variável não passa de uma conveniência pois apenas adiciona, no contexto de toda definição/tipo indutivo/prova dentro da seção, um termo do tipo \texttt{nat}
      chamado \texttt{Modalities}. Ou seja, adiciona um argumento/premissa já instanciado, este que se torna um termo quantificado universalmente quando o objeto definido dentro da seção é invocado fora dela.
      \begin{lstlisting}[language=coq]
    Require Import Nat.
    Section MultiModal.
      Variable Modalities: nat.
      Definition foo (n: nat): nat :=
        match leb n Modalities with
        | true  => 0
        | false => 1
        end.
      Check foo. (*foo: nat -> nat*)
      (*...*)
    End MultiModal.
    Check foo. (*foo: nat -> nat -> nat*)
      \end{lstlisting}

      A partir destas definições, foi implementada uma função recursiva que verifica se uma fórmula pode ser deduzida num sistema multimodal, onde uma fórmula \PHI pode ser deduzida num
      sistema multimodal com \textit{x} modalidades se, e somente se, para toda subfórmula de \PHI da forma \(\Box_{i} \psi\) ou \(\Diamond_{i} \psi\), \(i < x\).
      Uma função semelhante é definida para verificar dedutibilidade de teorias (listas de fórmulas).
      \begin{lstlisting}[language=coq]
    Fixpoint deducible_formula (f: MMformula): Prop :=
      match f with
      | MMLit  _                  => True
      | MMNeg f1                  => deducible_formula f1
      | MMBox x f1  | MMDia x f1  => x < Modalities /\ deducible_formula f1
      | MMAnd f1 f2 | MMOr f1 f2 | MMImplies f1 f2 =>
        deducible_formula f1 /\ deducible_formula f2
      end.
    Fixpoint deducible_theory (T: MMtheory): Prop :=
      match T with
      | [ ]    => True
      | h :: t => (deducible_formula h) /\ (deducible_theory t)
      end.
      \end{lstlisting}

      Frames e modelos para o sistema multimodal são definidos de forma semelhante ao que é feito na prova de conceito, onde um frame multimodal contém um conjunto de mundos,
      uma lista de relações de acessibilidade definidas sobre o conjunto de mundos e uma prova de que há tantas relações quanto há modalidades no sistema multimodal, já um modelo multimodal
      contém um frame multimodal e uma função de valoração definida sobre o conjunto de mundos do frame.
      \begin{lstlisting}[language=coq]
    Record nFrame: Type :={
      nW      : Set;
      nR      : list (nW -> nW -> Prop);
      rel_cond: (length nR) = Modalities
    }.
    Record nModel: Type := {
      nF: nFrame;
      nV: nat -> (nW nF) -> Prop
    }.
      \end{lstlisting}

      Para acessar uma relação arbitrária do conjunto (lista) de relações de um n-frame, foi definida uma função, chamada \texttt{get\_rel}, que apenas encapsula a função
      \texttt{nth} da biblioteca padrão e foi definida uma relação (vazia) especial, chamada \texttt{dummyRel}, que é usada como o retorno padrão da função \texttt{nth}.
      É de interesse ressaltar que esta relação especial só será retornada pela função \texttt{get\_rel} caso os outros argumentos passados a ela sejam inválidos,
      por exemplo caso seja passado um índice maior que o tamanho da lista ou seja passada uma lista vazia. Também foram provados alguns teoremas sobre a corretude
      da função \texttt{get\_rel}.
      \begin{lstlisting}[language=coq]
    Definition dummyRel (X: Set) := (fun x: X => (fun y: X => False)).
    Definition get_rel (X: Set) (lR: list (X -> X -> Prop)) (index: nat) :=
      nth index lR (dummyRel X).
    Lemma get_rel_sound: forall X lR n,
      length lR < n -> (get_rel X lR n) = (dummyRel X).
    Lemma get_rel_sound2: forall X lR n,
      ~ In (dummyRel X) lR -> n < length lR -> (get_rel X lR n) <> (dummyRel X).
      \end{lstlisting}

      Não foi possível representar a união de frames como foi descrito na Definição~\ref{def:Fusao} (mais será comentado sobre isso na Seção~\ref{sec:Dificuldades}),
      foram apenas definidas funções que separam um n-frame em um ou mais frames, algo semelhante foi definido para n-modelos:
      \begin{lstlisting}[language=coq]
    Definition split_frame (F: nFrame): list Frame:=
      match F with
        | Build_nFrame nW nR _ => map (Build_Frame nW) nR
      end.
    Definition nFrame_to_Frame (F: nFrame) (index: nat): Frame :=
      match F with
        | Build_nFrame nW nR _ => Build_Frame nW (get_rel nW nR index)
      end.
    Definition nModel_to_Model (M: nModel) (index: nat): Model :=
      match M with
        | Build_nModel (Build_nFrame nW nR _) V =>
          Build_Model (Build_Frame nW (get_rel nW nR index)) V
      end.
      \end{lstlisting}

      Com isso então foi definida a valoração de fórmulas no sistema multimodal, onde só é possível valorar fórmulas caso elas sejam dedutíveis no sistema multimodal em questão
      e uma fórmula que contém uma modalidade de índice \textit{x} será valorada com base na x-ésima relação do frame do modelo em questão:
      \begin{lstlisting}[language=coq]
    Fixpoint valuation (M: nModel) (w: nW (nF M)) (f: MMformula): Prop:=
      match f with
      | MMLit i     => (nV  M) i w
      | MMNeg f1    => deducible_formula f1 ->
        (~ valuation M w f1)
      | MMBox i f1  => deducible_formula (MMBox i f1) ->
        (forall w', (get_rel (nW (nF M)) (nR (nF M)) i) w w' -> valuation M w' f1)
      | MMDia i f1  => deducible_formula (MMDia i f1) ->
        (exists w', (get_rel (nW (nF M)) (nR (nF M)) i) w w' /\ valuation M w' f1)
      | MMAnd f1 f2 => deducible_formula (MMAnd f1 f2) ->
        (valuation M w f1 /\ valuation M w f2)
      | MMOr f1 f2 => deducible_formula (MMOr f1 f2) ->
        (valuation M w f1 \/ valuation M w f2)
      | MMImplies f1 f2 => deducible_formula (MMImplies f1 f2) ->
        (valuation M w f1 -> valuation M w f2)
      end.
      \end{lstlisting}

      Com base nesta definição de valoração, foram definidas relações de consequência semântica e foi provado que a valoração (ou consequência semântica) em n-modelos é uma generalização da
      valoração (consequência semântica) em modelos, tal qual foi feito para a prova de conceito.
      \begin{lstlisting}[language=coq]
    Theorem MMvaluation_generalization: forall modalities W lR RC V f n,
      let NF := Build_nFrame modalities W lR RC in
      let NM := Build_nModel modalities NF V in
      let M := (nModel_to_Model modalities NM n) in
      deducible_formula modalities (formula_to_MMformula f n) ->
        forall w, fun_validation M w f <->
        valuation modalities NM w (formula_to_MMformula f n).
      \end{lstlisting}

      Foi definido um conjunto de axiomas e um sistema de Hilbert para a lógica multimodal, de maneira semelhante ao que foi feito na biblioteca base e na prova de conceito,
      com tipos indutivos representando axiomas e derivações no sistema de Hilbert e uma função que transforma objetos do tipo de axiomas em fórmulas multimodais.
      \begin{lstlisting}[language=coq]
    Inductive MMaxiom : Set :=
      | MMax1  : MMformula -> MMformula -> MMaxiom
      | MMax2  : MMformula -> MMformula -> MMformula -> MMaxiom
      (*algumas linhas foram omitidas*)
      | MMax10 : MMformula -> MMformula -> MMaxiom
      | MMaxK  : nat       -> MMformula -> MMformula -> MMaxiom
      (*algumas linhas foram omitidas*)
      | MMaxGL : nat       -> MMformula -> MMaxiom.
    Definition MMinstance (a: MMaxiom): MMformula :=
      match a with
      | MMax1   f1 f2    => <! f1 -> (f2 -> f1) !>
      | MMax2   f1 f2 f3 => <! (f1 -> (f2 -> f3)) -> ((f1 -> f2) -> (f1 -> f3)) !>
      (*algumas linhas foram omitidas*)
      | MMax10  f1 f2    => <! ~~f1 -> f1 !>
      | MMaxK   i f1 f2  => <! [i](f1 -> f2) -> ([i] f1 -> [i] f2) !>
      (*algumas linhas foram omitidas*)
      | MMaxGL  i f      => <! [i]([i]f -> f) -> [i]f !>
      end.
    Reserved Notation "A ; G |--M p" (at level 110, no associativity).
    Inductive MMdeduction (A: MMaxiom -> Prop): MMtheory -> MMformula -> Prop :=
      | MMPrem: forall (G: MMtheory) (f: MMformula) (i: nat),
                      (deducible_theory G) -> (nth_error G i = Some f) -> A; G |--M f
      | MMAx: forall (G: MMtheory) (a: MMaxiom) (f: MMformula),
                    A a -> (deducible_formula f) -> MMinstance a = f ->
                    (deducible_theory G) -> A; G |--M f
      | MMMp: forall (G: MMtheory) (f1 f2: MMformula),
                    (deducible_formula <!f1 -> f2!>) -> (deducible_theory G) ->
                    (A; G |--M (<!f1 -> f2!>)) -> (A; G |--M f1) -> (A; G |--M f2)
      | MMNec: forall (G: MMtheory) (f: MMformula) (i: nat),
                      i < Modalities -> (deducible_formula f) -> (deducible_theory G) ->
                      (A; G |--M f) -> (A; G |--M <![i]f!>)
    where "A ; G |--M p" := (MMdeduction A G p).
      \end{lstlisting}

      A partir destas definições foram descritos sistemas axiomáticos para a lógica multimodal, em específico, foram modeladas versões multimodais de cada sistema axiomático na
      biblioteca base:
      \begin{lstlisting}[language=coq]
    Inductive Kn (index: list nat): MMaxiom -> Prop :=
      | Kn_ax1: forall f1 f2, (deducible_formula (MMinstance (MMax1 f1 f2))) ->
          Kn index (MMax1   f1 f2)
      | Kn_ax2: forall f1 f2 f3, (deducible_formula (MMinstance (MMax2 f1 f2 f3))) ->
        Kn index (MMax2   f1 f2 f3)
        (*algumas linhas foram omitidas*)
      | Kn_axK: forall i f1 f2, In i index ->
        (deducible_formula (MMinstance (MMaxK i f1 f2))) -> Kn index (MMaxK i f1 f2)
      | Kn_axPos: forall i f1 f2, In i index ->
        (deducible_formula (MMinstance (MMaxPos i f1 f2))) -> Kn index (MMaxPos i f1 f2).
      \end{lstlisting}
      Estes sistemas são parametrizados por uma lista de números naturais, que representam as modalidades daquele sistema. Então, por exemplo, caso um sistema seja parametrizado
      pela lista [1,2,3], então as modalidades deste sistema serão \(\Box_{1}/\Diamond_{1}, \Box_{2}/\Diamond_{2} \text{ e } \Box_{3}/\Diamond_{3}\).
      Para definir um sistema que contém todas as modalidades até a variável \texttt{Modalities}, basta passar o parâmetro \texttt{seq 0 Modalities},
      a função \texttt{seq}, que é definida na biblioteca padrão, computa a lista de todos os naturais menores que o segundo argumento, iniciando no primeiro. Ou seja,
      \texttt{seq 0 Modalities} irá retornar a lista [0, \dots, \texttt{Modalities}-1].

      Foram modelados sistemas axiomáticos que representam a fusão (tal qual apresentada na Definição~\ref{def:Fusao}) de outros dois sistemas axiomáticos, sejam eles dois sistemas
      monomodais (sistema \texttt{join}), um sistema monomodal e outro sistema multimodal (sistema \texttt{join\_one}) ou dois sistemas multimodais (sistema \texttt{join\_two}).
      \begin{lstlisting}[language=coq]
    Inductive join (S1 S2: axiom -> Prop) (index1 index2: nat):
      list nat -> MMaxiom -> Prop :=
        | derivable_S1: forall a b, S1 a -> axiom_to_MMaxiom index1 a b ->
          deducible_formula (MMinstance b) ->
            join S1 S2 index1 index2 (index1 :: index2 :: nil) b
        | derivable_S2: forall a b, S2 a -> axiom_to_MMaxiom index2 a b ->
          deducible_formula (MMinstance b) ->
            join S1 S2 index1 index2 (index1 :: index2 :: nil) b.
    Inductive join_one (S1: axiom -> Prop) (S2: list nat -> MMaxiom -> Prop)
      (index1: nat) (index2: list nat): list nat -> MMaxiom -> Prop :=
        | derivable_S1_one: forall a b, S1 a -> axiom_to_MMaxiom index1 a b ->
          deducible_formula (MMinstance b) ->
            join_one S1 S2 index1 index2 (index1 :: index2) b
        | derivable_S2_one: forall a, S2 index2 a ->
          join_one S1 S2 index1 index2 (index1 :: index2) a.
    Inductive join_two (S1 S2: list nat -> MMaxiom -> Prop) (index1 index2: list nat):
      list nat -> MMaxiom -> Prop :=
        | derivable_S1_two: forall a, S1 index1 a ->
          join_two S1 S2 index1 index2 (index1 ++ index2) a
        | derivable_S2_two: forall a, S2 index2 a ->
          join_two S1 S2 index1 index2 (index1 ++ index2) a.
      \end{lstlisting}
      Estes sistemas utilizam a mesma noção de parametrização por listas de índices de modalidades que os sistemas multimodais apresentados anteriormente, sendo que as listas
      de índices destes sistemas resultantes de fusão é gerada a partir das listas de índices dos sistemas unidos. No caso da junção envolvendo sistemas monomodais,
      um número natural é atribuído a cada sistema, para servir de índice das suas modalidades quando este for elevado para o sistema multimodal.

      Para definir a fusão de sistemas axiomáticos foi necessário antes definir uma forma de transformar axiomas do sistema monomodal para o sistema multimodal,
      o que foi feito por meio de um predicado definido indutivamente.
      \begin{lstlisting}[language=coq]
    Inductive axiom_to_MMaxiom (index: nat): axiom -> MMaxiom -> Prop :=
      | transform_ax1: forall f1 f2, axiom_to_MMaxiom index (ax1 f1 f2)
          (MMax1 (formula_to_MMformula f1 index) (formula_to_MMformula f2 index))
      | transform_ax2: forall f1 f2 f3, axiom_to_MMaxiom index (ax2 f1 f2 f3)
          (MMax2 (formula_to_MMformula f1 index) (formula_to_MMformula f2 index)
            (formula_to_MMformula f3 index))
      (*algumas linhas foram omitidas*)
      | transform_axK: forall f1 f2, axiom_to_MMaxiom index (axK f1 f2)
          (MMaxK index (formula_to_MMformula f1 index) (formula_to_MMformula f2 index))
      (*algumas linhas foram omitidas*)
      | transform_axGL: forall f, axiom_to_MMaxiom index (axGL f)
          (MMaxGL  index (formula_to_MMformula f index)).
      \end{lstlisting}

      Por fim, foi provado que toda fórmula derivável no sistema \textbf{K} também é derivável no sistema \textbf{K}\textsubscript{n} e que a fusão de sistemas dedutivos preserva
      derivações, ou seja, toda fórmula derivável num sistema \(\textit{S}_1\) também será derivável no sistema \(\textit{S}_1 \oplus \textit{S}_2\) para qualquer \(\textit{S}_2\),
      sejam estes sistemas mono ou multimodais.
      \begin{lstlisting}[language=coq]
    Theorem MMdeduction_generalization_Kn: forall modalities indexes n G f,
      let K_to_Kn := formula_to_MMformula in
      n < modalities -> In n indexes -> deduction K G f ->
      MMdeduction modalities (Kn modalities indexes)
        (theory_to_MMtheory G n) (K_to_Kn f n).
    Theorem join_preserves_deduction: forall modalities S1 n1 G f,
      let K_to_Kn := formula_to_MMformula in
      n1 < modalities -> deduction S1 G f ->
      forall S2 n2 b, (forall a, axiom_to_MMaxiom n1 a b) ->
        join modalities S1 S2 n1 n2 (n1 :: n2 :: nil) b ->
        MMdeduction modalities (join modalities S1 S2 n1 n2 (n1 :: n2 :: nil))
          (theory_to_MMtheory G n1) (K_to_Kn f n1).
    Theorem join_two_preserves_deduction: forall modalities S1 S2 l1 l2 G f a,
      MMdeduction modalities (S1 l1) G f -> join_two S1 S2 l1 l2 (l1 ++ l2) a ->
      MMdeduction modalities (join_two S1 S2 l1 l2 (l1 ++ l2)) G f.
      \end{lstlisting}

      Isso conclui a modelagem de lógicas multimodais no Coq com base na biblioteca de lógica modal apresentada no início deste capítulo. Devido às complexidades impostas
      pela modelagem no Coq e restrições de tempo, não foi possível modelar provas de transferência de propriedades descritas na Seção~\ref{sec:Preservacao}, porém, os resultados
      obtidos pela prova de conceito e de tentativas de começar a modelagem desta prova indicam que é possível provar, pelo menos, a transferência de corretude.

    % \subsection{Modelagem de um Problema}
    %   \label{subsec:ProblemaMultimodal}
    %   Para demonstrar a aplicabilidade da extensão da biblioteca modal descrita neste capítulo, tentou-se modelar um problema que envolva múltiplas modalidades.
    %   O problema selecionado foi o problema dos homens sábios, uma charada epistêmico que envolve o conhecimento de (usualmente) 3 agentes, cada um que pode ser
    %   representado por uma modalidade distinta, o que o torna ideal para servir de exemplo de aplicação dos desenvolvimentos deste trabalho.

    %   A charada tem diversas formulações diferentes, porém a formulação seleciona é a seguinte, retirada de~\cite{benzmuller2019universal}: ``\textit{Era uma vez um rei que
    %   queria descobrir o mais sábio dos seus três sábios. Para isso, o rei os colocou em um círculo de forma que qualquer um conseguisse ver e ouvir os outros dois, mas nenhum conseguia
    %   ver a si mesmo, então o rei os disse que colocaria uma marca branca ou preta na testa de cada um e que uma das marcas certamente seria branca. O rei, então, perguntou a cada
    %   um se ele sabia a cor da sua marca. Após algum tempo, o mais sábio respondeu que sabia que sua marca era branca.}''.

    %   Em~\cite{benzmuller2019universal} o autor apresenta uma modelagem de lógicas multimodais em Isabelle/HOL por meio de um \textit{shallow embedding} semântico, sobre o qual
    %   a charada é modelada e a sua resposta é dada pelo provadores automáticos embutidos em Isabelle. Tentou-se replicar a modelagem deste trabalho no presente trabalho,
    %   inicialmente por meios sintáticos e após por meios semânticos. Porém, devido a restrições de tempo, não foi possível replicar totalmente a modelagem da charada, apesar
    %   que foi possível modelar parte considerável dela, como os agentes, o conhecimento de cada agente e o conhecimento comum dentre os agentes.

    \section{Dificuldades na Implementação}
      \label{sec:Dificuldades}
      Um dos pontos que causou grande dificuldade na implementação foi a definição das linguagens, tanto para o sistema \SisT quanto para o sistema multimodal.
      Em específico, o problema era como seria possível implementar no Coq as linguagens de tal forma que elas representassem corretamente suas respectivas apresentações,
      e também que fosse possível definir traduções entre as linguagens da biblioteca base e do sistema multimodal. A solução selecionada
      resolve esses problemas, porém, uma limitação desta solução é que ele não representa a união de assinaturas de duas linguagens distintas\footnote{A impossibilidade
      de modelar a união de assinaturas de linguagens com tipos indutivos no Coq não é uma hipótese a ser descartada, talvez outra abordagem seja necessária
      para tratar este problema.}. A necessidade de realizar traduções também não é ideal, pois limita a expressividade dos sistemas desenvolvidos.

      Outro ponto de grande dificuldade foi na definição e tradução de frames para o sistema multimodal. Inicialmente, pretendia-se definir um n-frame a partir
      da união de frames da biblioteca base, tal e qual é feita na definição de fusão de lógicas, porém isso não é possível devido ao fato que o conjunto de mundos
      dos frames da biblioteca base são objetos do tipo \texttt{Set}. Isto gera dois problemas: igualdade entre objetos em \texttt{Set} não é a mesma que igualdade
      entre conjuntos e o Coq não consegue verificar se os conjuntos de mundos de dois frames distintos são iguais sem saber como estes frames são construídos.

      Este segundo problema se mostrou o maior, pois torna muito difícil (ou até impossível) obter a lista de relações de acessibilidade de frames a partir de uma lista de frames,
      algo necessário para representar a união de vários frames para a obtenção de um n-frame. Considerando uma função que recebe uma lista de frames como argumento e
      que deve retornar a lista das relações de acessibilidade de todos os frames na lista de frames, qual será o tipo do seu retorno?
      Certamente seria da forma \texttt{list(X -> X -> Prop)} onde \texttt{X: Set} e \texttt{X} é o conjunto de mundo dos frames da lista, porém o Coq não consegue
      verificar se \texttt{X} é conjunto de mundos de todos os frames da lista, pois não sabe como eles são construídos, logo ele não consegue verificar se o tipo
      da função é válido e, portanto, não permite a definição desta função. Este mesmo motivo torna muito difícil a conversão de n-modelos multimodais para modelos
      monomodais, mas, ao invés do problema estar na lista de relações de frames, está na função de valoração dos n-modelos.

      Para resolver este problema, uma possível solução seria alterar a definição de frames da biblioteca base para que todo frame seja parametrizado por algum tipo
      \texttt{T} e então o conjunto de mundos do frame seria do tipo \texttt{T -> Prop}, ou seja, seria a função característica de um conjunto de objetos que
      habitam o tipo \texttt{T}\footnote{O autor vem por meio desta nota expressar seu grande desgosto de trabalhar com teoria de conjuntos no Coq.}.
      Essa não é a única maneira de modelar conjuntos, no Coq, porém talvez seja a mais adequada para esta situação.

      Outro problema está relacionado com a lista de relações de um n-frame. Como é necessário acessar elementos arbitrários desta lista, foi utilizada a função
      \texttt{nth} da biblioteca padrão do Coq, que retorna o n-ésimo elemento de uma lista, porém esta função requer um objeto do mesmo tipo que os objetos na
      lista para ser retornado caso tente-se acessar um elemento maior que o tamanho da lista. Para tanto, foi definida uma relação (vazia) ``especial'' chamada \texttt{dummyRel},
      apresentada anteriormente, porém, o problema com essa forma de lidar com isso é que esta é uma relação válida, logo ela poderia estar contida na lista de relações de algum
      n-frame, portanto, caso essa relação fosse retornada ao aplicar a função numa lista de relações que contém uma relação vazia, seria impossível determinar se a função
      teve esse retorno pois não encontrou o elemento na lista de relações ou porque essa era a relação selecionada.

      Por fim, provar a transferência de corretude, tanto na prova de conceito quanto na modelagem final dos sistemas multimodais, se mostrou um problema maior
      do que o esperado. Apesar de ter sido possível provar a corretude do sistema \SisT na prova de conceito, por ser uma prova direta que não necessitou das premissas
      de corretude dos sistemas base, tal prova não foi uma prova de transferência. Este resultado inicial indica que, caso seja possível provar esse fato no Coq,
      talvez essa prova não seja pelo método de transferência, ou pelo menos que essa prova não seria tão simples quanto ela é no ``papel e caneta''.
      Mais ainda, para a implementação dos sistemas multimodais foi possível formular um predicado de corretude
      porém, devido a restrições de tempo, a complexidade dessa prova e as dificuldades envolvendo frames descritas anteriormente, a prova de corretude de fato não pode ser concluída.